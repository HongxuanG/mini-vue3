{"version":3,"file":"guide-toy-vue3.esm.js","sources":["../src/shared/index.ts","../src/reactivity/effect.ts","../src/reactivity/baseHandlers.ts","../src/reactivity/reactive.ts","../src/runtime-core/componentEmit.ts","../src/runtime-core/componentProps.ts","../src/runtime-core/componentPublicInstance.ts","../src/runtime-core/componentSlots.ts","../src/runtime-core/component.ts","../src/runtime-core/vnode.ts","../src/runtime-core/renderer.ts","../src/runtime-core/createApp.ts","../src/runtime-core/h.ts","../src/runtime-core/helper/renderSlot.ts"],"sourcesContent":["export * from './shapeFlags'\nexport const extend = Object.assign\n// 判断value是否object或者array\nexport const isObject = (value: unknown) => {\n  return value !== null && typeof value === 'object'\n}\nexport const isString = (value: unknown) => {\n  return typeof value === 'string'\n}\n// 类型保护\nexport const isFunction = (value: unknown): value is Function => {\n  return typeof value === 'function'\n}\nexport const isArray = Array.isArray\nexport const hasChanged = (newValue: any, value: any) => {\n  return !Object.is(newValue, value)\n}\nexport const isOn = (key: string) => /^on[A-Z]/.test(key)\nexport const hasOwn = (target: Record<string, any>, key: any) => Object.prototype.hasOwnProperty.call(target, key)\n\n// 把kabobCase => camelCase\nexport const camelCase = (str: string) => {\n  return str.replace(/-(\\w)/g, (_, $1: string) => {\n    return $1.toUpperCase()\n  })\n}\n// 首字母大写\nexport const capitalize = (str: string) => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n// 事件前缀追加'on'\nexport const toHandlerKey = (eventName: string) => {\n  return eventName ? 'on' + capitalize(eventName) : ''\n}\n","import { extend } from '../shared'\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\nexport type Dep = Set<ReactiveEffect>\r\nexport class ReactiveEffect {\r\n  public deps: Dep[] = []\r\n  public active = true // 该effect是否存活\r\n  public onStop?: () => void\r\n  constructor(public fn: Function, public scheduler?: EffectScheduler) {}\r\n  run() {\r\n    // 如果effect已经被杀死了，被删除了（stop()函数相关）\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    // 为什么要在这里把this赋值给activeEffect呢？因为这里是fn执行之前，就是track依赖收集执行之前，又是effect开始执行之后，\r\n    // this能捕捉到这个依赖，将这个依赖赋值给activeEffect是刚刚好的时机\r\n    activeEffect = this\r\n    shouldTrack = true // 把开关打开让他可以收集依赖\r\n    let returnValue = this.fn() // 执行fn的时候，fn里面会执行get操作，之后就会执行track收集依赖，因为shouldTrack是true，所以依赖收集完成\r\n    // 之后把shouldTrack关闭，这样就没办法在track函数里面收集依赖了\r\n    shouldTrack = false\r\n\r\n    return returnValue\r\n  }\r\n  stop() {\r\n    // 追加active 标识是为了性能优化，避免每次循环重复调用stop同一个依赖的时候\r\n    if (this.active) {\r\n      cleanupEffect(this)\r\n      this.onStop?.()\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n// 清除指定依赖\r\nfunction cleanupEffect(effect: ReactiveEffect) {\r\n  // 对effect解构，解出deps，减少对象在词法环境寻找属性的次数\r\n  const { deps } = effect\r\n  if (deps.length !== 0) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\nconst targetMap = new Map<Record<EffectKey, any>, Map<EffectKey, Set<IDep>>>()\r\n// 当前正在执行的effect\r\nlet activeEffect: ReactiveEffect\r\nlet shouldTrack = false\r\ntype EffectKey = string\r\ntype IDep = ReactiveEffect\r\n// 这个track的实现逻辑很简单：添加依赖\r\nexport function track(target: Record<EffectKey, any>, key: EffectKey) {\r\n  // 这里为什么要多一层非空判断呢？\r\n  // 我们查看reactive.spec.ts里面的测试用例\r\n  // 测试用例里根本就没有调用effect()，所以没有执行ReactiveEffect的run()自然activeEffect也就是undefined了\r\n  // if (!activeEffect) return\r\n  // 应不应该收集依赖，从而避免删了依赖又重新添加新的依赖\r\n  // if (!shouldTrack) return\r\n  if (!isTracking()) return\r\n  // 寻找dep依赖的执行顺序\r\n  // target -> key -> dep\r\n  let depsMap = targetMap.get(target)\r\n  /**\r\n   * 这里有个疑问：target为{ num: 11 } 的时候我们能获取到depsMap，之后我们count.num++，为什么target为{ num: 12 } 的时候我们还能获取得到相同的depsMap呢？\r\n   * 这里我的理解是 targetMap的key存的只是target的引用 存的字符串就不一样了\r\n   */\r\n  // 解决初始化没有depsMap的情况\r\n  if (!depsMap) {\r\n    depsMap = new Map()\r\n    targetMap.set(target, depsMap)\r\n  }\r\n  // dep是一个Set对象，存放着这个key相对应的所有依赖\r\n  let dep = depsMap.get(key)\r\n  // 如果没有key相对应的Set 初始化Set\r\n  if (!dep) {\r\n    dep = new Set()\r\n    depsMap.set(key, dep)\r\n  }\r\n  trackEffect(dep)\r\n}\r\n// 依赖收集\r\nexport function trackEffect(dep: Dep){\r\n  // 避免不必要的add操作\r\n  if (dep.has(activeEffect)) return\r\n  // 将activeEffect实例对象add给deps\r\n  dep.add(activeEffect)\r\n  // activeEffect的deps 接收 Set<ReactiveEffect>类型的deps\r\n  // 供删除依赖的时候使用(停止监听依赖)\r\n  activeEffect.deps.push(dep)\r\n}\r\nexport function isTracking() {\r\n  return activeEffect !== undefined && shouldTrack\r\n}\r\n// 这个trigger的实现逻辑很简单：找出target的key对应的所有依赖，并依次执行\r\nexport function trigger(target: Record<EffectKey, any>, key: EffectKey) {\r\n  const depsMap = targetMap.get(target)\r\n  const dep = depsMap?.get(key)\r\n  if (dep) {\r\n    triggerEffect(dep)\r\n  }\r\n}\r\n// 触发依赖\r\nexport function triggerEffect(dep: Dep){\r\n  for (let effect of dep) {\r\n    if (effect.scheduler) {\r\n      effect.scheduler()\r\n    } else {\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\nexport interface EffectOption {\r\n  scheduler?: EffectScheduler\r\n  onStop?: () => void\r\n}\r\n// 里面存有一个匿名函数\r\nexport interface EffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n// 根据官方给出的介绍：effect会立即触发这个函数，同时响应式追踪其依赖\r\nexport function effect<T = any>(fn: () => T, option?: EffectOption): EffectRunner {\r\n  let _effect = new ReactiveEffect(fn)\r\n  if (option) {\r\n    extend(_effect, option)\r\n  }\r\n  _effect.run()\r\n  // 注意这里的this指向，return 出去的run方法，方法体里需要用到this，且this必须指向ReactiveEffect的实例对象\r\n  // 不用bind重新绑定this，this会指向undefined\r\n  let runner = _effect.run.bind(_effect) as EffectRunner\r\n  // 这里的effect挂载在了函数runner上，作为属性，这是利用了js中函数可以挂在属性的特性\r\n  // 之后呢，实现stop的时候runner就能拿到ReactiveEffect实例对象了\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\nexport function stop(runner: EffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n","import { track, trigger } from './effect'\r\nimport { reactive, ReactiveFlags, readonly } from './reactive'\r\nimport { extend, isObject } from '../shared'\r\n// 此处调用一次createSetter和getter，为了不在每次使用mutableHandlers的时候重复调用\r\nconst get = createGetter()\r\nconst set = createSetter()\r\nconst readonlyGet = createGetter(true)\r\nconst shallowReadonlyGet = createGetter(true, true)\r\n// shallowReactive的get操作\r\nconst shallowGet = createGetter(false, true)\r\n// shallowReactive的set操作\r\nconst shallowSet = createSetter(true)\r\n\r\n// 高阶函数\r\nexport function createGetter<T extends object>(isReadonly = false, isShallow = false) {\r\n  return function get(target: T, key: string | symbol) {\r\n    // isReactive和isReadonly 都是根据传入的参数 `isReadonly`来决定是否返回true | false的\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return isShallow\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n    let res = Reflect.get(target, key)\r\n\r\n    if (!isReadonly) {\r\n      // 判断是否readonly\r\n      // 依赖收集\r\n      track(target, key as string)\r\n    }\r\n    if (isShallow) {\r\n      return res\r\n    }\r\n    // 之前都是只实现表面一层的reactive，我们现在实现嵌套对象的reactive\r\n    if (isObject(res)) {\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n    return res\r\n  }\r\n}\r\n// 这个isShallow涉及到的是shallowReactive\r\nexport function createSetter<T extends object>(isShallow = false) {\r\n  return function set(target: T, key: string | symbol, value: any) {\r\n    let success: boolean\r\n    success = Reflect.set(target, key, value)\r\n    // 触发依赖\r\n    trigger(target, key as string)\r\n    return success\r\n  }\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set,\r\n}\r\nexport const readonlyHandlers: ProxyHandler<object> = {\r\n  get: readonlyGet,\r\n  set(target, key, value) {\r\n    console.warn(`${JSON.stringify(target)} do not set ${String(key)} value ${value}, because it is readonly`)\r\n    return true\r\n  },\r\n}\r\nexport const shallowReadonlyHandlers: ProxyHandler<object> = extend({}, readonlyHandlers, {\r\n  get: shallowReadonlyGet,\r\n})\r\nexport const shallowReactiveHandlers: ProxyHandler<object> = extend({}, mutableHandlers, {\r\n  get: shallowGet,\r\n  set: shallowSet,\r\n})\r\nexport function createReactiveObject<T extends object>(target: T, handlers: ProxyHandler<T>) {\r\n  if(!isObject(target)) {\r\n    console.warn(`target ${target} is not a object`)\r\n    return target\r\n  }\r\n  return new Proxy(target, handlers)\r\n}\r\n","import { createReactiveObject, mutableHandlers, readonlyHandlers, shallowReadonlyHandlers, shallowReactiveHandlers } from './baseHandlers'\r\n\r\nexport enum ReactiveFlags {\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n// 给value做类型批注，让value有以下几个可选属性,不然该死的value飘红 --isReactive函数和isReadonly函数  说的就是你们\r\nexport interface Target {\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean;\r\n  [ReactiveFlags.IS_READONLY]?: boolean;\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean;\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport function reactive<T extends object>(target: T) {\r\n  return createReactiveObject<T>(target, mutableHandlers)\r\n}\r\n\r\n// 其实就是一个没有set操作的reactive（会深层readonly）\r\nexport function readonly<T extends object>(target: T) {\r\n  return createReactiveObject<T>(target, readonlyHandlers)\r\n}\r\n\r\n// 浅浅的readonly一下，创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)\r\nexport function shallowReadonly<T extends object>(target: T) {\r\n  return createReactiveObject<T>(target, shallowReadonlyHandlers)\r\n}\r\nexport function shallowReactive<T extends object>(target: T){\r\n  return createReactiveObject<T>(target, shallowReactiveHandlers)\r\n}\r\n\r\nexport function isReactive(value: unknown) {\r\n  // target没有__v_isReactive这个属性，为什么还要写target['__v_isReactive']呢？因为这样就会触发proxy的get操作，\r\n  // 通过判断createGetter传入的参数isReadonly是否为true，否则isReactive为true\r\n  // 优化点：用enum管理状态，增强代码可读性\r\n  return !!(value as Target)[ReactiveFlags.IS_REACTIVE]\r\n}\r\n\r\nexport function isReadonly(value: unknown){\r\n  // 同上\r\n  return !!(value as Target)[ReactiveFlags.IS_READONLY]\r\n}\r\n// 检查对象是否是由 reactive 或 readonly 创建的 proxy。\r\nexport function isProxy(value: unknown){\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n// 检查对象是否 开启 shallow mode\r\nexport function isShallow(value: unknown){\r\n  return !!(value as Target)[ReactiveFlags.IS_SHALLOW]\r\n}\r\n// 返回 reactive 或 readonly 代理的原始对象\r\nexport function toRaw<T>(observed: T): T{\r\n  // observed存在，触发get操作，在createGetter直接return target\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n","import { camelCase, toHandlerKey } from \"../shared\"\n\nexport function emit(instance: any, event: string, ...args: unknown[]){\n  const {props} = instance\n\n  \n  const eventName = toHandlerKey(camelCase(event))\n  console.log(eventName)\n  const handler = props[eventName]\n  handler && handler(...args)\n}\n","export function initProps(instance: any, rawProps: any) {\n  instance.props = rawProps || {}\n}\n","import { hasOwn } from '../shared'\n\nexport type PublicPropertiesMap = Record<string, (i: any) => any>\n// 实例property\nconst publicPropertiesMap: PublicPropertiesMap = {\n  $el: (i: any) => i.vnode.el,\n  $slots: (i: any) => i.slots\n}\nexport const publicInstanceProxyHandlers: ProxyHandler<any> = {\n  get({ _: instance }, key: string) {\n    const { setupState, props } = instance\n    // 在setup的return中寻找key\n    if (hasOwn(setupState, key)) {\n      return setupState[key]\n      // 在setup的参数props中寻找key\n    } else if (hasOwn(props, key)) {\n      return props[key]\n    }\n    // 在publicPropertiesMap中寻找key，并调用，返回结果\n    const publicGetter = publicPropertiesMap[key]\n    if (publicGetter) {\n      return publicGetter(instance)\n    }\n  },\n}\n","import { isArray, ShapeFlags } from '../shared'\r\n// 如果children里面有slot，那么把slot挂载到instance上\r\nexport function initSlots(instance: any, children: any) {\r\n  const { vnode } = instance\r\n  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\r\n    normalizeObjectSlots(instance.slots, children)\r\n  }\r\n}\r\n// 具名name作为instance.slots的属性名，属性值是vnode\r\nfunction normalizeObjectSlots(slots: any, children: any) {\r\n  console.log('slots children===>' ,children)\r\n  // 遍历对象\r\n  for (let key in children) {\r\n    const value = children[key]\r\n    slots[key] = (props: any) => normalizeSlotValue(value(props))\r\n    // slots[key] = normalizeSlotValue(value)\r\n  }\r\n  // slots = normalizeSlotValue(slots)\r\n}\r\nfunction normalizeVNodeSlots(slots: any, children: any){\r\n  \r\n}\r\n// 转成数组\r\nfunction normalizeSlotValue(value: any) {\r\n  return isArray(value) ? value : [value]\r\n}\r\n","import { shallowReadonly } from '../reactivity/reactive'\r\nimport { isFunction, isObject } from '../shared'\r\nimport { emit } from './componentEmit'\r\nimport { initProps } from './componentProps'\r\nimport { publicInstanceProxyHandlers } from './componentPublicInstance'\r\nimport { initSlots } from './componentSlots'\r\n\r\nexport type Data = Record<string, unknown>\r\n\r\nexport function createComponentInstance(vnode: any) {\r\n  const type = vnode.type\r\n  const instance = {\r\n    vnode,\r\n    type,\r\n    render: null,\r\n    setupState: {},\r\n    props: {},\r\n    emit: () => {},\r\n    slots: {},\r\n  }\r\n  instance.emit = emit.bind(null, instance) as any\r\n  return instance\r\n}\r\n//\r\nexport function setupComponent(instance: any) {\r\n  // 初始化组件外部传给组件的props\r\n  initProps(instance, instance.vnode.props)\r\n  initSlots(instance, instance.vnode.children)\r\n  setupStatefulComponent(instance)\r\n}\r\n// 初始化有状态的组件\r\nfunction setupStatefulComponent(instance: any) {\r\n  const Component = instance.type\r\n  // 解决render返回的h()函数里面this的问题，指向setup函数\r\n  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)\r\n  const { setup } = Component\r\n  // 有时候用户并没有使用setup()\r\n  if (setup) {\r\n    // 处理setup的返回值，如果返回的是对象，那么把对象里面的值注入到template上下文中\r\n    // 如果是一个函数h()，那么直接render\r\n\r\n    const setupResult = setup(shallowReadonly(instance.props), {\r\n      emit: instance.emit\r\n    })\r\n\r\n    handleSetupResult(instance, setupResult)\r\n  }\r\n  finishComponentSetup(instance)\r\n}\r\n// 处理组件的setup的返回值\r\nfunction handleSetupResult(instance: any, setupResult: any) {\r\n  // TODO handle function\r\n  if (isFunction(setupResult)) {\r\n    instance.render = setupResult\r\n  } else if (isObject(setupResult)) {\r\n    // 把setup返回的对象挂载到setupState上\r\n    instance.setupState = setupResult\r\n  }\r\n}\r\n// 结束组件的安装\r\nfunction finishComponentSetup(instance: any) {\r\n  const Component = instance.type // 遇到h('div',{}, this.name)  这里Component将为'div'\r\n\r\n  if (instance) {\r\n    instance.render = Component.render\r\n  }\r\n}\r\n","import { isArray, isObject, isString } from '../shared'\r\nimport { ShapeFlags } from '../shared/shapeFlags'\r\n\r\n// fragment用来创建一个碎片组件，这个碎片组件并不会真正的渲染出一个<Fragment></Fragment>\r\n// 他的作用就是渲染slots的时候摆脱div的包裹，让slots直接渲染在父组件上。\r\nexport const Fragment = Symbol('Fragment')\r\nexport const Text = Symbol('Text')\r\n\r\n// type是 <template></template>经过编译之后具有render()函数的对象，此外还有__file和__hmrId这些无关的属性\r\nexport function createVNode(type: any, props?: any, children?: any) {\r\n  const vnode = {\r\n    type,\r\n    props,\r\n    children,\r\n    shapeFlag: getShapeFlag(type),\r\n    el: null,\r\n  }\r\n  normalizeChildren(vnode, children)\r\n  return vnode\r\n}\r\n// 根据vnode.type标志vnode类型\r\nfunction getShapeFlag(type: any) {\r\n  return isString(type) \r\n    ? ShapeFlags.ELEMENT\r\n    : isObject(type)\r\n    ? ShapeFlags.STATEFUL_COMPONENT\r\n    : 0\r\n}\r\n// 给vnode.shapeFlag追加标识\r\nfunction normalizeChildren(vnode: any, children: any){\r\n  // | 左右两边为0 则为0   可以用于给二进制指定的位数修改成1  例如：0100 | 0001 = 0101\r\n  // 在这里相当于给vnode追加额外的标识\r\n  if(isString(children)){\r\n    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN\r\n    // 子级是数组\r\n  } else if(isArray(children)){\r\n    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN\r\n  }\r\n  // vnode是组件\r\n  if(vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT){\r\n    // 子级是对象\r\n    if(isObject(children) ){\r\n      vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN\r\n    }\r\n  }\r\n}\r\n// 创建文本虚拟节点 为什么需要创建文本虚拟节点？直接填上文本不行吗？h('div',{},[Foo, '我是文本'])\r\n// 挂载html的时候因为children是数组，必然经过mountChildren的循环，然后patch，单纯填上文本是没办法渲染出来的\r\n// 因为patch并没有针对纯文本做处理，你只能通过div（或者其他html元素）包裹起来生成一个vnode才行，像这样：h('div',{},[Foo, h('div',{}, '我是文本')])\r\nexport function createTextVNode(text: string){\r\n  return createVNode(Text, {}, text)\r\n}\r\n","import { ShapeFlags, isOn, isFunction } from '../shared'\r\nimport { createComponentInstance, setupComponent } from './component'\r\nimport { Fragment, Text } from './vnode'\r\n\r\nexport function render(vnode: any, container: any) {\r\n  // 做patch算法\r\n  patch(vnode, container)\r\n}\r\n\r\n// 例如：\r\n/**\r\n * template被编译成  {...., setup(){}, render(){}, ....}  这样一个特殊对象\r\n * 或者{..., data, methods, render(){}, ...}\r\n *\r\n * 之后 这个特殊对象作为参数会传入 createVNode()  创建虚拟dom\r\n */\r\n// 传入vnode，递归对一个组件或者普通元素进行拆箱，在内部对vnode的type判断执行不同的处理函数\r\n\r\nfunction patch(vnode: any, container: any) {\r\n  // 检查是什么类型的vnode\r\n  console.log('vnode', vnode.type)\r\n  const { type } = vnode\r\n  switch (type) {\r\n    case Fragment:\r\n      processFragment(vnode, container)\r\n      break\r\n    case Text:\r\n      processText(vnode, container)\r\n      break\r\n    default: {\r\n      // & 左右两边同时为1 则为1   可以应用在 0001 & 0010 判断指定的位置是否为1  这个案例会输出0000  所以为false 指定的位置并没有相同\r\n      if (vnode.shapeFlag & ShapeFlags.ELEMENT) {\r\n        // 是一个普通元素？处理vnode是普通标签的情况\r\n        processElement(vnode, container)\r\n      } else if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\r\n        // 是一个组件？处理vnode是组件的情况\r\n        processComponent(vnode, container)\r\n      }\r\n      break\r\n    }\r\n  }\r\n}\r\nfunction processText(vnode: any, container: any) {\r\n  mountText(vnode, container)\r\n}\r\nfunction processFragment(vnode: any, container: any) {\r\n  mountChildren(vnode, container)\r\n}\r\n// 处理组件的情况\r\nfunction processComponent(vnode: any, container: any) {\r\n  mountComponent(vnode, container)\r\n}\r\n// 处理元素的情况\r\nfunction processElement(vnode: any, container: any) {\r\n  mountElement(vnode, container)\r\n}\r\n// 最后，它把setup()的返回值挂载在组件的instance的setupState上\r\n// instance.type的render()函数挂载在组件的instance的render上\r\nfunction mountComponent(vnode: any, container: any) {\r\n  const instance = createComponentInstance(vnode)\r\n  // 安装组件\r\n  setupComponent(instance)\r\n\r\n  // \r\n  setupRenderEffect(instance, vnode, container)\r\n}\r\nfunction mountElement(vnode: any, container: any) {\r\n  // 注意：这个vnode并非是组件的vnode，而是HTML元素的vnode\r\n  console.log('mountElement', vnode)\r\n  const el = (vnode.el = document.createElement(vnode.type) as HTMLElement)\r\n  let { children, props } = vnode\r\n  // 子节点是文本节点\r\n  if (vnode.shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n    el.textContent = children\r\n    // 子节点是数组\r\n  } else if (vnode.shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n    mountChildren(vnode, el)\r\n  }\r\n  let val: any\r\n  // 对vnode的props进行处理，把虚拟属性添加到el\r\n  for (let key of Object.getOwnPropertyNames(props).values()) {\r\n    val = props[key]\r\n    if (Array.isArray(val)) {\r\n      el.setAttribute(key, val.join(' '))\r\n    } else if (isOn(key) && isFunction(val)) {\r\n      // 添加事件\r\n      el.addEventListener(key.slice(2).toLowerCase(), val)\r\n    } else {\r\n      el.setAttribute(key, val)\r\n    }\r\n  }\r\n  container.append(el)\r\n}\r\nfunction mountText(vnode: any, container: any) {\r\n  const { children } = vnode\r\n  const textNode = (vnode.el = document.createTextNode(children))\r\n  container.append(textNode)\r\n}\r\nfunction mountChildren(vnode: any, container: any) {\r\n  vnode.children.forEach((vnode: any) => {\r\n    patch(vnode, container)\r\n  })\r\n}\r\nfunction setupRenderEffect(instance: any, vnode: any, container: any) {\r\n  console.log(instance)\r\n  // 这个render()已经在finishComponentSetup处理过了，就是 instance.type.render() 特殊对象的render()\r\n  // render函数内部的this指向 修改为 setupStatefulComponent中定义的proxy对象\r\n  const subTree = instance.render.call(instance.proxy)\r\n  // 对子树进行拆箱操作 递归进去\r\n  patch(subTree, container)\r\n  // 代码到了这里，组件内的所有element已经挂在到document里面了\r\n  vnode.el = subTree.el\r\n}\r\n","import { render } from './renderer'\r\nimport { createVNode } from './vnode'\r\n\r\nexport function createApp(rootComponent: any) {\r\n  const mount = (rootContainer: any) => {\r\n    const vnode = createVNode(rootComponent)\r\n\r\n    render(vnode, rootContainer)\r\n  }\r\n  return {\r\n    mount,\r\n  }\r\n}\r\n","import { createVNode } from './vnode'\r\n\r\nexport function h(type: any, props?: any, children?: any) {\r\n  return createVNode(type, props, children)\r\n}\r\n","import { createVNode, Fragment } from '../vnode'\r\n// slots已经在initSlots中做了处理（把slots挂载到instance.slots上）\r\nexport function renderSlot(slots: any, name: string = 'default', props: any) {\r\n  const slot = slots[name]\r\n  console.log('slot==>', slots, slot)\r\n  if (slot) {\r\n    if (typeof slot === 'function') {\r\n      // slots有可能是对象，数组\r\n      // 但是这里额外渲染了一层div，怎么去解决呢？定义一个vnode.type叫Fragment，内部只处理children\r\n      // 就好像走了processElement()逻辑一样，不用的是他不会给Fragment生成HTML元素节点\r\n      // return createVNode('div', {}, slot(props))\r\n      // 执行slot(props)会返回一个vnode数组\r\n      return createVNode(Fragment, {}, slot(props))\r\n      // return createVNode(Fragment, {}, slot)\r\n    }\r\n  } else {\r\n    return slots\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}