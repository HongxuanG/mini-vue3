{"version":3,"file":"guide-toy-vue3.cjs.js","sources":["../src/shared/index.ts","../src/reactivity/effect.ts","../src/reactivity/baseHandlers.ts","../src/reactivity/reactive.ts","../src/runtime-core/componentEmit.ts","../src/runtime-core/componentProps.ts","../src/runtime-core/componentPublicInstance.ts","../src/runtime-core/componentSlots.ts","../src/runtime-core/component.ts","../src/runtime-core/vnode.ts","../src/runtime-core/renderer.ts","../src/runtime-core/createApp.ts","../src/runtime-core/h.ts","../src/runtime-core/helper/renderSlot.ts"],"sourcesContent":["export * from './shapeFlags'\nexport const extend = Object.assign\n// 判断value是否object或者array\nexport const isObject = (value: unknown) => {\n  return value !== null && typeof value === 'object'\n}\nexport const isString = (value: unknown) => {\n  return typeof value === 'string'\n}\n// 类型保护\nexport const isFunction = (value: unknown): value is Function => {\n  return typeof value === 'function'\n}\nexport const isArray = Array.isArray\nexport const hasChanged = (newValue: any, value: any) => {\n  return !Object.is(newValue, value)\n}\nexport const isOn = (key: string) => /^on[A-Z]/.test(key)\nexport const hasOwn = (target: Record<string, any>, key: any) => Object.prototype.hasOwnProperty.call(target, key)\n\n// 把kabobCase => camelCase\nexport const camelCase = (str: string) => {\n  return str.replace(/-(\\w)/g, (_, $1: string) => {\n    return $1.toUpperCase()\n  })\n}\n// 首字母大写\nexport const capitalize = (str: string) => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n// 事件前缀追加'on'\nexport const toHandlerKey = (eventName: string) => {\n  return eventName ? 'on' + capitalize(eventName) : ''\n}\n","import { extend } from '../shared'\n\nexport type EffectScheduler = (...args: any[]) => any\nexport type Dep = Set<ReactiveEffect>\nexport class ReactiveEffect {\n  public deps: Dep[] = []\n  public active = true // 该effect是否存活\n  public onStop?: () => void\n  constructor(public fn: Function, public scheduler?: EffectScheduler) {}\n  run() {\n    // 如果effect已经被杀死了，被删除了（stop()函数相关）\n    if (!this.active) {\n      return this.fn()\n    }\n    // 为什么要在这里把this赋值给activeEffect呢？因为这里是fn执行之前，就是track依赖收集执行之前，又是effect开始执行之后，\n    // this能捕捉到这个依赖，将这个依赖赋值给activeEffect是刚刚好的时机\n    activeEffect = this\n    shouldTrack = true // 把开关打开让他可以收集依赖\n    let returnValue = this.fn() // 执行fn的时候，fn里面会执行get操作，之后就会执行track收集依赖，因为shouldTrack是true，所以依赖收集完成\n    // 之后把shouldTrack关闭，这样就没办法在track函数里面收集依赖了\n    shouldTrack = false\n\n    return returnValue\n  }\n  stop() {\n    // 追加active 标识是为了性能优化，避免每次循环重复调用stop同一个依赖的时候\n    if (this.active) {\n      cleanupEffect(this)\n      this.onStop?.()\n      this.active = false\n    }\n  }\n}\n// 清除指定依赖\nfunction cleanupEffect(effect: ReactiveEffect) {\n  // 对effect解构，解出deps，减少对象在词法环境寻找属性的次数\n  const { deps } = effect\n  if (deps.length !== 0) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\nconst targetMap = new Map<Record<EffectKey, any>, Map<EffectKey, Set<IDep>>>()\n// 当前正在执行的effect\nlet activeEffect: ReactiveEffect\nlet shouldTrack = false\ntype EffectKey = string\ntype IDep = ReactiveEffect\n// 这个track的实现逻辑很简单：添加依赖\nexport function track(target: Record<EffectKey, any>, key: EffectKey) {\n  // 这里为什么要多一层非空判断呢？\n  // 我们查看reactive.spec.ts里面的测试用例\n  // 测试用例里根本就没有调用effect()，所以没有执行ReactiveEffect的run()自然activeEffect也就是undefined了\n  // if (!activeEffect) return\n  // 应不应该收集依赖，从而避免删了依赖又重新添加新的依赖\n  // if (!shouldTrack) return\n  if (!isTracking()) return\n  // 寻找dep依赖的执行顺序\n  // target -> key -> dep\n  let depsMap = targetMap.get(target)\n  /**\n   * 这里有个疑问：target为{ num: 11 } 的时候我们能获取到depsMap，之后我们count.num++，为什么target为{ num: 12 } 的时候我们还能获取得到相同的depsMap呢？\n   * 这里我的理解是 targetMap的key存的只是target的引用 存的字符串就不一样了\n   */\n  // 解决初始化没有depsMap的情况\n  if (!depsMap) {\n    depsMap = new Map()\n    targetMap.set(target, depsMap)\n  }\n  // dep是一个Set对象，存放着这个key相对应的所有依赖\n  let dep = depsMap.get(key)\n  // 如果没有key相对应的Set 初始化Set\n  if (!dep) {\n    dep = new Set()\n    depsMap.set(key, dep)\n  }\n  trackEffect(dep)\n}\n// 依赖收集\nexport function trackEffect(dep: Dep){\n  // 避免不必要的add操作\n  if (dep.has(activeEffect)) return\n  // 将activeEffect实例对象add给deps\n  dep.add(activeEffect)\n  // activeEffect的deps 接收 Set<ReactiveEffect>类型的deps\n  // 供删除依赖的时候使用(停止监听依赖)\n  activeEffect.deps.push(dep)\n}\nexport function isTracking() {\n  return activeEffect !== undefined && shouldTrack\n}\n// 这个trigger的实现逻辑很简单：找出target的key对应的所有依赖，并依次执行\nexport function trigger(target: Record<EffectKey, any>, key: EffectKey) {\n  const depsMap = targetMap.get(target)\n  const dep = depsMap?.get(key)\n  if (dep) {\n    triggerEffect(dep)\n  }\n}\n// 触发依赖\nexport function triggerEffect(dep: Dep){\n  for (let effect of dep) {\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\nexport interface EffectOption {\n  scheduler?: EffectScheduler\n  onStop?: () => void\n}\n// 里面存有一个匿名函数\nexport interface EffectRunner<T = any> {\n  (): T\n  effect: ReactiveEffect\n}\n// 根据官方给出的介绍：effect会立即触发这个函数，同时响应式追踪其依赖\nexport function effect<T = any>(fn: () => T, option?: EffectOption): EffectRunner {\n  let _effect = new ReactiveEffect(fn)\n  if (option) {\n    extend(_effect, option)\n  }\n  _effect.run()\n  // 注意这里的this指向，return 出去的run方法，方法体里需要用到this，且this必须指向ReactiveEffect的实例对象\n  // 不用bind重新绑定this，this会指向undefined\n  let runner = _effect.run.bind(_effect) as EffectRunner\n  // 这里的effect挂载在了函数runner上，作为属性，这是利用了js中函数可以挂在属性的特性\n  // 之后呢，实现stop的时候runner就能拿到ReactiveEffect实例对象了\n  runner.effect = _effect\n  return runner\n}\nexport function stop(runner: EffectRunner) {\n  runner.effect.stop()\n}\n","import { track, trigger } from './effect'\nimport { reactive, ReactiveFlags, readonly } from './reactive'\nimport { extend, isObject } from '../shared'\n// 此处调用一次createSetter和getter，为了不在每次使用mutableHandlers的时候重复调用\nconst get = createGetter()\nconst set = createSetter()\nconst readonlyGet = createGetter(true)\nconst shallowReadonlyGet = createGetter(true, true)\n// shallowReactive的get操作\nconst shallowGet = createGetter(false, true)\n// shallowReactive的set操作\nconst shallowSet = createSetter(true)\n\n// 高阶函数\nexport function createGetter<T extends object>(isReadonly = false, isShallow = false) {\n  return function get(target: T, key: string | symbol) {\n    // isReactive和isReadonly 都是根据传入的参数 `isReadonly`来决定是否返回true | false的\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return isShallow\n    } else if (key === ReactiveFlags.RAW) {\n      return target\n    }\n    let res = Reflect.get(target, key)\n\n    if (!isReadonly) {\n      // 判断是否readonly\n      // 依赖收集\n      track(target, key as string)\n    }\n    if (isShallow) {\n      return res\n    }\n    // 之前都是只实现表面一层的reactive，我们现在实现嵌套对象的reactive\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n    return res\n  }\n}\n// 这个isShallow涉及到的是shallowReactive\nexport function createSetter<T extends object>(isShallow = false) {\n  return function set(target: T, key: string | symbol, value: any) {\n    let success: boolean\n    success = Reflect.set(target, key, value)\n    // 触发依赖\n    trigger(target, key as string)\n    return success\n  }\n}\n\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n}\nexport const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  set(target, key, value) {\n    console.warn(`${JSON.stringify(target)} do not set ${String(key)} value ${value}, because it is readonly`)\n    return true\n  },\n}\nexport const shallowReadonlyHandlers: ProxyHandler<object> = extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet,\n})\nexport const shallowReactiveHandlers: ProxyHandler<object> = extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet,\n})\nexport function createReactiveObject<T extends object>(target: T, handlers: ProxyHandler<T>) {\n  if(!isObject(target)) {\n    console.warn(`target ${target} is not a object`)\n    return target\n  }\n  return new Proxy(target, handlers)\n}\n","import { createReactiveObject, mutableHandlers, readonlyHandlers, shallowReadonlyHandlers, shallowReactiveHandlers } from './baseHandlers'\n\nexport enum ReactiveFlags {\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  IS_SHALLOW = '__v_isShallow',\n  RAW = '__v_raw'\n}\n// 给value做类型批注，让value有以下几个可选属性,不然该死的value飘红 --isReactive函数和isReadonly函数  说的就是你们\nexport interface Target {\n  [ReactiveFlags.IS_REACTIVE]?: boolean;\n  [ReactiveFlags.IS_READONLY]?: boolean;\n  [ReactiveFlags.IS_SHALLOW]?: boolean;\n  [ReactiveFlags.RAW]?: any\n}\n\nexport function reactive<T extends object>(target: T) {\n  return createReactiveObject<T>(target, mutableHandlers)\n}\n\n// 其实就是一个没有set操作的reactive（会深层readonly）\nexport function readonly<T extends object>(target: T) {\n  return createReactiveObject<T>(target, readonlyHandlers)\n}\n\n// 浅浅的readonly一下，创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)\nexport function shallowReadonly<T extends object>(target: T) {\n  return createReactiveObject<T>(target, shallowReadonlyHandlers)\n}\nexport function shallowReactive<T extends object>(target: T){\n  return createReactiveObject<T>(target, shallowReactiveHandlers)\n}\n\nexport function isReactive(value: unknown) {\n  // target没有__v_isReactive这个属性，为什么还要写target['__v_isReactive']呢？因为这样就会触发proxy的get操作，\n  // 通过判断createGetter传入的参数isReadonly是否为true，否则isReactive为true\n  // 优化点：用enum管理状态，增强代码可读性\n  return !!(value as Target)[ReactiveFlags.IS_REACTIVE]\n}\n\nexport function isReadonly(value: unknown){\n  // 同上\n  return !!(value as Target)[ReactiveFlags.IS_READONLY]\n}\n// 检查对象是否是由 reactive 或 readonly 创建的 proxy。\nexport function isProxy(value: unknown){\n  return isReactive(value) || isReadonly(value)\n}\n// 检查对象是否 开启 shallow mode\nexport function isShallow(value: unknown){\n  return !!(value as Target)[ReactiveFlags.IS_SHALLOW]\n}\n// 返回 reactive 或 readonly 代理的原始对象\nexport function toRaw<T>(observed: T): T{\n  // observed存在，触发get操作，在createGetter直接return target\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\n  return raw ? toRaw(raw) : observed\n}\n","import { camelCase, toHandlerKey } from \"../shared\"\n\nexport function emit(instance: any, event: string, ...args: unknown[]){\n  const {props} = instance\n\n  \n  const eventName = toHandlerKey(camelCase(event))\n  console.log(eventName)\n  const handler = props[eventName]\n  handler && handler(...args)\n}\n","export function initProps(instance: any, rawProps: any) {\n  instance.props = rawProps || {}\n}\n","import { hasOwn } from '../shared'\n\nexport type PublicPropertiesMap = Record<string, (i: any) => any>\n// 实例property\nconst publicPropertiesMap: PublicPropertiesMap = {\n  $el: (i: any) => i.vnode.el,\n  $slots: (i: any) => i.slots\n}\nexport const publicInstanceProxyHandlers: ProxyHandler<any> = {\n  get({ _: instance }, key: string) {\n    const { setupState, props } = instance\n    // 在setup的return中寻找key\n    if (hasOwn(setupState, key)) {\n      return setupState[key]\n      // 在setup的参数props中寻找key\n    } else if (hasOwn(props, key)) {\n      return props[key]\n    }\n    // 在publicPropertiesMap中寻找key，并调用，返回结果\n    const publicGetter = publicPropertiesMap[key]\n    if (publicGetter) {\n      return publicGetter(instance)\n    }\n  },\n}\n","import { isArray, ShapeFlags } from '../shared'\n// 如果children里面有slot，那么把slot挂载到instance上\nexport function initSlots(instance: any, children: any) {\n  // const { vnode } = instance\n  // if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\n  //   normalizeObjectSlots(instance.slots, children)\n  // }\n  console.log('children', children)\n  instance.slots = normalizeSlotValue(children)\n}\nfunction normalizeObjectSlots(slots: any, children: any) {\n  console.log('slots children===>' ,children)\n  for (let key in children) {\n    const value = children[key]\n\n    slots[key] = (props: any) => normalizeSlotValue(value(props))\n  }\n  // slots = normalizeSlotValue(slots)\n}\nfunction normalizeVNodeSlots(slots: any, children: any){\n  \n}\nfunction normalizeSlotValue(value: any) {\n  return isArray(value) ? value : [value]\n}\n","import { shallowReadonly } from '../reactivity/reactive'\nimport { isFunction, isObject } from '../shared'\nimport { emit } from './componentEmit'\nimport { initProps } from './componentProps'\nimport { publicInstanceProxyHandlers } from './componentPublicInstance'\nimport { initSlots } from './componentSlots'\n\nexport type Data = Record<string, unknown>\n\nexport function createComponentInstance(vnode: any) {\n  const type = vnode.type\n  const instance = {\n    vnode,\n    type,\n    render: null,\n    setupState: {},\n    props: {},\n    emit: () => {},\n    slots: {},\n  }\n  instance.emit = emit.bind(null, instance) as any\n  return instance\n}\n//\nexport function setupComponent(instance: any) {\n  // 初始化组件外部传给组件的props\n  initProps(instance, instance.vnode.props)\n  initSlots(instance, instance.vnode.children)\n  setupStatefulComponent(instance)\n}\n// 初始化有状态的组件\nfunction setupStatefulComponent(instance: any) {\n  const Component = instance.type\n  // 解决render返回的h()函数里面this的问题，指向setup函数\n  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)\n  const { setup } = Component\n  // 有时候用户并没有使用setup()\n  if (setup) {\n    // 处理setup的返回值，如果返回的是对象，那么把对象里面的值注入到template上下文中\n    // 如果是一个函数h()，那么直接render\n\n    const setupResult = setup(shallowReadonly(instance.props), {\n      emit: instance.emit\n    })\n\n    handleSetupResult(instance, setupResult)\n  }\n  finishComponentSetup(instance)\n}\n// 处理组件的setup的返回值\nfunction handleSetupResult(instance: any, setupResult: any) {\n  // TODO handle function\n  if (isFunction(setupResult)) {\n    instance.render = setupResult\n  } else if (isObject(setupResult)) {\n    // 把setup返回的对象挂载到setupState上\n    instance.setupState = setupResult\n  }\n}\n// 结束组件的安装\nfunction finishComponentSetup(instance: any) {\n  const Component = instance.type // 遇到h('div',{}, this.name)  这里Component将为'div'\n\n  if (instance) {\n    instance.render = Component.render\n  }\n}\n","import { isArray, isObject, isString } from '../shared'\nimport { ShapeFlags } from '../shared/shapeFlags'\n\n// fragment用来创建一个碎片组件，这个碎片组件并不会真正的渲染出一个<Fragment></Fragment>\n// 他的作用就是渲染slots的时候摆脱div的包裹，让slots直接渲染在父组件上。\nexport const Fragment = Symbol('Fragment')\nexport const Text = Symbol('Text')\n\n// type是 <template></template>经过编译之后具有render()函数的对象，此外还有__file和__hmrId这些无关的属性\nexport function createVNode(type: any, props?: any, children?: any) {\n  const vnode = {\n    type,\n    props,\n    children,\n    shapeFlag: getShapeFlag(type),\n    el: null,\n  }\n  normalizeChildren(vnode, children)\n  return vnode\n}\n// 根据vnode.type标志vnode类型\nfunction getShapeFlag(type: any) {\n  return isString(type) \n    ? ShapeFlags.ELEMENT\n    : isObject(type)\n    ? ShapeFlags.STATEFUL_COMPONENT\n    : 0\n}\n// 给vnode.shapeFlag追加标识\nfunction normalizeChildren(vnode: any, children: any){\n  // | 左右两边为0 则为0   可以用于给二进制指定的位数修改成1  例如：0100 | 0001 = 0101\n  // 在这里相当于给vnode追加额外的标识\n  if(isString(children)){\n    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN\n    // 子级是数组\n  } else if(isArray(children)){\n    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN\n  }\n  // vnode是组件\n  if(vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT){\n    // 子级是对象\n    if(isObject(children) ){\n      vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN\n    }\n  }\n}\n// 创建文本虚拟节点 为什么需要创建文本虚拟节点？直接填上文本不行吗？h('div',{},[Foo, '我是文本'])\n// 挂载html的时候因为children是数组，必然经过mountChildren的循环，然后patch，单纯填上文本是没办法渲染出来的\n// 因为patch并没有针对纯文本做处理，你只能通过div（或者其他html元素）包裹起来生成一个vnode才行，像这样：h('div',{},[Foo, h('div',{}, '我是文本')])\nexport function createTextVNode(text: string){\n  return createVNode(Text, {}, text)\n}\n","import { ShapeFlags, isOn, isFunction } from '../shared'\nimport { createComponentInstance, setupComponent } from './component'\nimport { Fragment, Text } from './vnode'\n\nexport function render(vnode: any, container: any) {\n  // 做patch算法\n  patch(vnode, container)\n}\n\n// 例如：\n/**\n * template被编译成  {...., setup(){}, render(){}, ....}  这样一个特殊对象\n * 或者{..., data, methods, render(){}, ...}\n *\n * 之后 这个特殊对象作为参数会传入 createVNode()  创建虚拟dom\n */\n// 传入vnode，递归对一个组件或者普通元素进行拆箱，在内部对vnode的type判断执行不同的处理函数\n\nfunction patch(vnode: any, container: any) {\n  // 检查是什么类型的vnode\n  console.log('vnode', vnode.type)\n  const { type } = vnode\n  switch (type) {\n    case Fragment:\n      processFragment(vnode, container)\n      break\n    case Text:\n      processText(vnode, container)\n      break\n    default: {\n      // & 左右两边同时为1 则为1   可以应用在 0001 & 0010 判断指定的位置是否为1  这个案例会输出0000  所以为false 指定的位置并没有相同\n      if (vnode.shapeFlag & ShapeFlags.ELEMENT) {\n        // 是一个普通元素？处理vnode是普通标签的情况\n        processElement(vnode, container)\n      } else if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n        // 是一个组件？处理vnode是组件的情况\n        processComponent(vnode, container)\n      }\n      break\n    }\n  }\n}\nfunction processText(vnode: any, container: any) {\n  mountText(vnode, container)\n}\nfunction processFragment(vnode: any, container: any) {\n  mountChildren(vnode, container)\n}\n// 处理组件的情况\nfunction processComponent(vnode: any, container: any) {\n  mountComponent(vnode, container)\n}\n// 处理元素的情况\nfunction processElement(vnode: any, container: any) {\n  mountElement(vnode, container)\n}\n// 最后，它把setup()的返回值挂载在组件的instance的setupState上\n// instance.type的render()函数挂载在组件的instance的render上\nfunction mountComponent(vnode: any, container: any) {\n  const instance = createComponentInstance(vnode)\n  // 安装组件\n  setupComponent(instance)\n\n  //\n  setupRenderEffect(instance, vnode, container)\n}\nfunction mountElement(vnode: any, container: any) {\n  // 注意：这个vnode并非是组件的vnode，而是HTML元素的vnode\n  console.log('mountElement', vnode)\n  const el = (vnode.el = document.createElement(vnode.type) as HTMLElement)\n  let { children, props } = vnode\n  // 子节点是文本节点\n  if (vnode.shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    el.textContent = children\n    // 子节点是数组\n  } else if (vnode.shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n    mountChildren(vnode, el)\n  }\n  let val: any\n  // 对vnode的props进行处理，把虚拟属性添加到el\n  for (let key of Object.getOwnPropertyNames(props).values()) {\n    val = props[key]\n    if (Array.isArray(val)) {\n      el.setAttribute(key, val.join(' '))\n    } else if (isOn(key) && isFunction(val)) {\n      // 添加事件\n      el.addEventListener(key.slice(2).toLowerCase(), val)\n    } else {\n      el.setAttribute(key, val)\n    }\n  }\n  container.append(el)\n}\nfunction mountText(vnode: any, container: any) {\n  const { children } = vnode\n  const textNode = (vnode.el = document.createTextNode(children))\n  container.append(textNode)\n}\nfunction mountChildren(vnode: any, container: any) {\n  vnode.children.forEach((vnode: any) => {\n    console.log('mountChildren==>', vnode)\n    patch(vnode, container)\n  })\n}\nfunction setupRenderEffect(instance: any, vnode: any, container: any) {\n  console.log(instance)\n  // 这个render()已经在finishComponentSetup处理过了，就是 instance.type.render() 特殊对象的render()\n  // render函数内部的this指向 修改为 setupStatefulComponent中定义的proxy对象\n  const subTree = instance.render.call(instance.proxy)\n  // 对子树进行拆箱操作 递归进去\n  patch(subTree, container)\n  // 代码到了这里，组件内的所有element已经挂在到document里面了\n  vnode.el = subTree.el\n}\n","import { render } from './renderer'\nimport { createVNode } from './vnode'\n\nexport function createApp(rootComponent: any) {\n  const mount = (rootContainer: any) => {\n    const vnode = createVNode(rootComponent)\n\n    render(vnode, rootContainer)\n  }\n  return {\n    mount,\n  }\n}\n","import { createVNode } from './vnode'\n\nexport function h(type: any, props?: any, children?: any) {\n  return createVNode(type, props, children)\n}\n","import { createVNode, Fragment } from '../vnode'\n// slots已经在initSlots中做了处理（把slots挂载到instance.slots上）\nexport function renderSlot(slots: any, name: string = 'default', props: any) {\n  // const slot = slots[name]\n  // if (slot){\n  //   if(typeof slot === 'function'){\n\n  //     // slots有可能是对象，数组\n  //     // 但是这里额外渲染了一层div，怎么去解决呢？定义一个vnode.type叫Fragment，内部只处理children\n  //     // 就好像走了processElement()逻辑一样，不用的是他不会给Fragment生成HTML元素节点\n  //     // return createVNode('div', {}, slot(props))\n  //     return createVNode(Fragment, {}, slot(props))\n  //   }\n  // }else{\n  //   return slots\n  // }\n  return createVNode('div', {}, slots)\n}\n"],"names":[],"mappings":"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"}