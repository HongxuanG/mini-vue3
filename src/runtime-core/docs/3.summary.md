## getCurrentInstance的实现

getCurrentInstance可以获取到内部函数的实例

> 注意：只能在setup或生命周期中使用

基于[官网描述](https://v3.cn.vuejs.org/api/composition-api.html#getcurrentinstance)的特性，我们来试一下实现它。

既然只能在setup内部使用，我们自然联想到之前章节的`setupStatefulComponent()`，它内部调用了`instance.type.setup()`函数

```typescript
function setupStatefulComponent(instance: any) {
  const Component = instance.type
  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)
  const { setup } = Component
  if (setup) {
    const setupResult = setup(shallowReadonly(instance.props), {
      emit: instance.emit
    })

    handleSetupResult(instance, setupResult)
  }
  finishComponentSetup(instance)
}
```
为了能对象的公用性，我们在全局定义一个`currentInstance`变量

```typescript

export let currentInstance = null
// 获取当前实例
export function getCurrentInstance(){
  return currentInstance
}
// 设置当前实例
function setCurrentInstance(instance: any){
  currentInstance = instance
}

```
`setCurrentInstance`的调用时机决定了`currentInstance`当前指向哪一个组件实例。

那什么时候设置`setCurrentInstance`为当前组件实例最好呢？

其实是确保`instance.type.setup`有值并且在`instance.type.setup`调用之前这个时机就是最佳时机。

```typescript
function setupStatefulComponent(instance: any) {
  const Component = instance.type
  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)
  const { setup } = Component
  if (setup) {
    // currentInstance设置为instance
    setCurrentInstance(instance)
    const setupResult = setup(shallowReadonly(instance.props), {
      emit: instance.emit
    })
    handleSetupResult(instance, setupResult)
    // 让currentInstance变为null
    setCurrentInstance(null)
  }
  finishComponentSetup(instance)
}
```
最后我们把`currentInstance`变为null，其实是为了使currentInstance在setup内部有值，这遵循了官方给出的特性。

这就是getCurrentInstance的实现。
## provide & inject实现

父组件和子组件之间共享数据我们可以通过很多种方式：
1. `vuex`
2. `props`和`emit`
3. 全局对象`globalProperties`
4. parent & 模板ref

> 注意：eventbus在vue3中已不再支持，需要自己手写实现。废除了`$on`、`$children`、$listeners

那如果子组件和祖先组件数据如何共享？props一层一层的传递？emit一层一层的暴露方法给父组件？这未免也太不优雅了吧！

`provide`和`inject`是这种应用场景的解决方案。

如何实现provide和inject？

> 下面我们把使用provide的组件称为`提供者`，把使用inject的组件称为`接收者`。

把提供者实例上的provide属性作为一个`容器`，这个容器就是提供给接收者的共享数据。

接收者如何拿到提供者的`共享数据`呢？

可以在接收者实例上添加一个parent字段，用来指定该组件实例的父组件实例是谁，从而拿到父组件实例的身上的provide这个容器。

在创建组件实例的时候为instance新增两个属性（provides、parent）
```typescript
export function createComponentInstance(vnode: any, parentComponent: any) {
  const type = vnode.type
  const instance = {
    vnode,
    type,
    render: null,
    setupState: {},
    props: {},
    emit: () => {},
    slots: {},
    provides: {} as Record<string, any>,  // 新增 
    parent: parentComponent, // 新增  父组件的组件实例
  }
  instance.emit = emit.bind(null, instance) as any
  return instance
}
```

根据官方的描述和例子，provide接收两个参数`name`和`value`，name用于标识那些提供给子组件的数据，value就是我们要对外提供的数据。

这里我把`instance.provides`初始化为一个对象，之所以选择用对象作为容器是因为provide具有键值关系。

`provide`把要提供的数据存储起来，所以大体上`provide`的实现如下：
```typescript
export function provide<T>(key: string | number, value: T){
  // 提供者
  
  const currentInstance: any = getCurrentInstance()
  if(currentInstance){
    let { provides } = currentInstance
    provides[key] = value
  }
}
```
`provide`已经实现了，那么`inject`他就是一个从容器中拿取数据的一个过程，不过这个容器要在parent（父组件）上获取父组件的provides。
```typescript
export function inject<T>(key: string, defaultValue?: unknown){
  // 接收者
  // 在哪里拿value呢？在instance的parent上面获取到父组件的instance然后点出provide
  const currentInstance: any = getCurrentInstance()
  if(currentInstance){
    const parentProvides = currentInstance.parent.provides

    return parentProvides[key]
  }
}
```
此时我在这里准备的demo就已经可以使用provide和inject完成父子组件的数据传参了。

```typescript
// 提供者
const Provider = {
  name: 'Provider',
  setup(){

    provide('foo', 'fooVal')
    provide('bar', 'barVal')
  },
  render(){
    return h('div', {}, [
      h('p', {}, 'Provider'),
      h(Consumer)
    ])
  }
}
// 接收者
const Consumer = {
  name: 'Consumer',
  setup(){
    const fooVal = inject('foo')
    const barVal = inject('bar')
    return {
      fooVal,
      barVal
    }
  },
  render(){
    return h('div', {}, `Consumer-${this.fooVal}-${this.barVal}`)
  }
}

```
[![XdJRrF.md.png](https://s1.ax1x.com/2022/06/04/XdJRrF.md.png)](https://imgtu.com/i/XdJRrF)

当然，不一定是父子组件这种关系这么简单，它可以是爷爷和孙子组件的关系、太爷爷和太孙子组件的关系......，这种情况给你如何处理？比如下面的情况：

我在Provider和Consumer中间加了一层组件叫`ProviderTwo`，用来模拟跨组件数据共享这样的情景。我们依然沿用之前的逻辑，发现`Consumer`的foo和bar为undefined。
```typescript
const Provider = {
  name: 'Provider',
  setup(){

    provide('foo', 'fooVal')
    provide('bar', 'barVal')
  },
  render(){
    return h('div', {}, [
      h('p', {}, 'Provider'),
      h(ProviderTwo)
    ])
  }
}
const ProviderTwo = {
  name: 'ProviderTwo',
  setup(){
  },
  render(){
    return h('div', {}, [
      h('p', {}, `ProviderTwo`),
      h(Consumer)
    ])
  }
}
const Consumer = {
  name: 'Consumer',
  setup(){
    const fooVal = inject('foo')
    const barVal = inject('bar')
    return {
      fooVal,
      barVal
    }
  },
  render(){
    return h('div', {}, `Consumer-${this.fooVal}-${this.barVal}`)
  }
}

```
[![XdNaDO.md.png](https://s1.ax1x.com/2022/06/04/XdNaDO.md.png)](https://imgtu.com/i/XdNaDO)

这是为什么呢？其实Consumer的父组件ProviderTwo并没有给provide属性提供数据，是个空对象。Consumer在使用inject的时候拿了ProviderTwo的空对象，结果当然为undefined。
```typescript
export function createComponentInstance(vnode: any, parentComponent: any) {
  const type = vnode.type
  const instance = {
    vnode,
    type,
    render: null,
    setupState: {},
    props: {},
    emit: () => {},
    slots: {},
    provides: {} as Record<string, any>,
    parent: parentComponent, // 父组件的组件实例
  }
  instance.emit = emit.bind(null, instance) as any
  return instance
}
```
我能想到的就，provides不再指向空对象，而是指向上一级父组件的provides，一层一层的指向父组件的provides，直到没有父组件为止。

我们来改写一下`createComponentInstance()`：
```typescript
export function createComponentInstance(vnode: any, parentComponent: any) {
  const type = vnode.type
  const instance = {
    vnode,
    type,
    render: null,
    setupState: {},
    props: {},
    emit: () => {},
    slots: {},
    provides: parentComponent ? parentComponent.provides : {} as Record<string, any>, // 确保中间层的组件没有提供provide时，子组件拿最近的有provide的父组件的数据
    parent: parentComponent, // 父组件的组件实例
  }
  instance.emit = emit.bind(null, instance) as any
  return instance
}
```
这样就解决了。
[![XdU1L8.md.png](https://s1.ax1x.com/2022/06/04/XdU1L8.md.png)](https://imgtu.com/i/XdU1L8)

需求再次升级，这次我们想在ProviderTwo组件内使用provide和inject，期望是：ProviderTwo组件能接收Provider的provide数据，Consumer能接收ProviderTwo的provide数据。

```typescript
export const Provider = {
  name: 'Provider',
  setup(){

    provide('foo', 'fooVal')
    provide('bar', 'barVal')
  },
  render(){
    return h('div', {}, [
      h('p', {}, 'Provider'),
      h(ProviderTwo)
    ])
  }
}
const ProviderTwo = {
  name: 'ProviderTwo',
  setup(){
    provide('foo', 'fooTwo')
    provide('bar', 'barTwo')
    // 期望得到provider的foo---fooVal，实际上得到的是fooTwo
    const foo = inject('foo')
    const bar = inject('bar')
    return {
      foo,
      bar
    }
  },
  render(){
    return h('div', {}, [
      h('p', {}, `ProviderTwo-${this.foo}-${this.bar}`),
      h(Consumer)
    ])
  }
}
const Consumer = {
  name: 'Consumer',
  setup(){
    const fooVal = inject('foo')
    const barVal = inject('bar')
    return {
      fooVal,
      barVal
    }
  },
  render(){
    return h('div', {}, `Consumer-${this.fooVal}-${this.barVal}`)
  }
}

```

[![XdYhy8.md.png](https://s1.ax1x.com/2022/06/04/XdYhy8.md.png)](https://imgtu.com/i/XdYhy8)

我们期望ProviderTwo的foo和bar应该是Provider所提供的fooVal和barVal，现实却是fooTwo和barTwo。这是为什么呢？


原因是：在`createComponentInstance()`的时候instance的provides是直接指向父组件的provides，而ProviderTwo组件中provides被重新赋值为fooTwo和barTwo，又因为provides是引用类型，所以它事实上间接改变了父组件的provides的值。

那么如何解决这个问题呢？



如何解决跨组件数据共享 provide初始化为parent.provide

既然要共享组件之间的数据，我们

如何解决中间层组件provide覆盖祖先组件的provide？  原型链object.create

给inject提供默认值

如果inject的默认值是函数的时候，在provide找不到key的时候执行默认值

