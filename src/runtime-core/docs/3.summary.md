## getCurrentInstance的实现

getCurrentInstance可以获取到内部函数的实例

> 注意：只能在setup或生命周期中使用

基于[官网描述](https://v3.cn.vuejs.org/api/composition-api.html#getcurrentinstance)的特性，我们来试一下实现它。

既然只能在setup内部使用，我们自然联想到之前章节的`setupStatefulComponent()`，它内部调用了`instance.type.setup()`函数

```typescript
function setupStatefulComponent(instance: any) {
  const Component = instance.type
  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)
  const { setup } = Component
  if (setup) {
    const setupResult = setup(shallowReadonly(instance.props), {
      emit: instance.emit
    })

    handleSetupResult(instance, setupResult)
  }
  finishComponentSetup(instance)
}
```
为了能对象的公用性，我们在全局定义一个`currentInstance`变量

```typescript

export let currentInstance = null
// 获取当前实例
export function getCurrentInstance(){
  return currentInstance
}
// 设置当前实例
function setCurrentInstance(instance: any){
  currentInstance = instance
}

```
`setCurrentInstance`的调用时机决定了`currentInstance`当前指向哪一个组件实例。

那什么时候设置`setCurrentInstance`为当前组件实例最好呢？

其实是确保`instance.type.setup`有值并且在`instance.type.setup`调用之前这个时机就是最佳时机。

```typescript
function setupStatefulComponent(instance: any) {
  const Component = instance.type
  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)
  const { setup } = Component
  if (setup) {
    // currentInstance设置为instance
    setCurrentInstance(instance)
    const setupResult = setup(shallowReadonly(instance.props), {
      emit: instance.emit
    })
    handleSetupResult(instance, setupResult)
    // 让currentInstance变为null
    setCurrentInstance(null)
  }
  finishComponentSetup(instance)
}
```
最后我们把`currentInstance`变为null，其实是为了使currentInstance在setup内部有值，这遵循了官方给出的特性。

这就是getCurrentInstance的实现。
## provide & inject实现

父组件和子组件之间共享数据我们可以通过很多种方式：
1. `vuex`
2. `props`和`emit`
3. 全局对象`globalProperties`
4. parent & 模板ref

> 注意：eventbus在vue3中已不再支持，需要自己手写实现。废除了`$on`、`$children`、$listeners

那如果子组件和祖先组件数据如何共享？props一层一层的传递？emit一层一层的暴露方法给父组件？这未免也太不优雅了吧！

`provide`和`inject`是这种应用场景的解决方案。

如何实现provide和inject？

> 下面我们把使用provide的组件称为`提供者`，把使用inject的组件称为`接收者`。

把提供者实例上的provide属性作为一个`容器`，这个容器就是提供给接收者的共享数据。

接收者如何拿到提供者的`共享数据`呢？

可以在接收者实例上添加一个parent字段，用来指定该组件实例的父组件实例是谁，从而拿到父组件实例的身上的provide这个容器。

在创建组件实例的时候为instance新增两个属性（provides、parent）
```typescript
export function createComponentInstance(vnode: any, parentComponent: any) {
  const type = vnode.type
  const instance = {
    vnode,
    type,
    render: null,
    setupState: {},
    props: {},
    emit: () => {},
    slots: {},
    provides: {} as Record<string, any>,  // 新增 
    parent: parentComponent, // 新增  父组件的组件实例
  }
  instance.emit = emit.bind(null, instance) as any
  return instance
}
```

根据官方的描述和例子，provide接收两个参数`name`和`value`，name用于标识那些提供给子组件的数据，value就是我们要对外提供的数据。

这里我把`instance.provides`初始化为一个对象，之所以选择用对象作为容器是因为provide具有键值关系。

`provide`把要提供的数据存储起来，所以大体上`provide`的实现如下：
```typescript
export function provide<T>(key: string | number, value: T){
  // 提供者
  
  const currentInstance: any = getCurrentInstance()
  if(currentInstance){
    let { provides } = currentInstance
    provides[key] = value
  }
}
```
`provide`已经实现了，那么`inject`他就是一个从容器中拿取数据的一个过程，不过这个容器要在parent（父组件）上获取父组件的provides。
```typescript
export function inject<T>(key: string, defaultValue?: unknown){
  // 接收者
  // 在哪里拿value呢？在instance的parent上面获取到父组件的instance然后点出provide
  const currentInstance: any = getCurrentInstance()
  if(currentInstance){
    const parentProvides = currentInstance.parent.provides

    return parentProvides[key]
  }
}
```

当然，不一定是父子组件这种关系这么简单，它可以是爷爷和孙子组件的关系、太爷爷和太孙子组件的关系......，这种情况给你如何处理？

我能想到的就，provides不再指向空对象，而是指向上一个父组件的provides，一层一层的指向父组件的provides，直到没有父组件为止。



如何解决跨组件数据共享 provide初始化为parent.provide

既然要共享组件之间的数据，我们

如何解决中间层组件provide覆盖祖先组件的provide？  原型链object.create

给inject提供默认值

如果inject的默认值是函数的时候，在provide找不到key的时候执行默认值

