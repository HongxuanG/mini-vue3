# 🚀vue3 render 渲染函数的功能实现以及巧妙的 vnode 类型分类！

## 前言

上篇讲解了template到挂载元素的过程，这篇我们来对render实现一些细节上的功能，其中源码有一些开发思路还是很值得我们去学习的

本篇文章主要内容：

1. 实现组件代理对象
2. 实现 shapeFlags
3. 实现注册事件功能
4. 实现组件 props 功能
5. 实现组件 emit 功能
6. 实现组件 slots 功能
7. 实现 Fragment 和 Text 类型节点

## render 的 this 指向是如何实现的？
有时候我们的h()函数需要获取setup返回的对象里面的某个属性，比如this.name

先看一个例子：
```typescript
export default {
  name: 'App',
  render() {
    // this指向通过proxy
    return h('div', {
      id: 'root',
      class: ['flex', 'container']
    }, this.name)
  },
  setup() {
    // 返回对象或者h()渲染函数
    return {
      name: 'hi my app'
    }
  }
}
```


可是这个this的指向分明就是指向的`render()`函数，如果不对this指向做处理，`this.name`将会得到undefined

其实this的指向并不重要，重要的是使用this可以获取setup的返回值、`$el`、`$slogs`以及外部传递进来的props的属性

思考一下，哪里能获取到setup的返回值呢？（setupState）

前面我们不是实现过`setupStatefulComponent()`方法吗？这个函数执行了setup()，并把setup的返回值setupResult挂载在了instance.setupState上。

那我们怎么通过this访问到setupState呢？

改变this的指向我们有call、bind、apply。我们要改变instance.render的this指向，并且让render执行，返回子树的vnode，我们选用`call`

我们定位到instance.render执行逻辑所在的setupRenderEffect上：
```typeScript
function setupRenderEffect(instance: any, vnode: any, container: any) {
  const subTree = instance.render.call(instance.setupState)
  // 对子树进行拆箱操作 递归进去
  patch(subTree, container)
  // 代码到了这里，组件内的所有element已经挂在到document里面了
  vnode.el = subTree.el
}
```
直接在call的第一个参数填上instance.setupState当然没问题，但是我们后续会有props、`$el`、`$slots`，这些参数都不在setup的返回值对象里面哦，所以我们需要new 一个 proxy对象，在get操作的时候判断key哪个对象的属性，并返回相应的键值。

```typescript
function setupStatefulComponent(instance: any) {
  const Component = instance.type
  // 解决render返回的h()函数里面this的问题，指向setup函数
  instance.proxy = new Proxy({ _: instance } as Data, publicInstanceProxyHandlers)
  const { setup } = Component
  // 有时候用户并没有使用setup()
  if (setup) {

    const setupResult = setup()

    handleSetupResult(instance, setupResult)
  }
  finishComponentSetup(instance)
}
export const publicInstanceProxyHandlers: ProxyHandler<any> = {
  // 通过target吧instance传递给get操作
  get({ _: instance }, key: string) {
    const { setupState } = instance
    // 在setup的return中寻找key
    if (hasOwn(setupState, key)) {
      return setupState[key]
    }
    // 后续我们这里还可能会返回props、`$el`、`$slots`等等
  },
}
```
这个hasOwn的实现就是Object.property.hasOwnProperty.call()

再次更改上面的`setupRenderEffect()`
```typescript
function setupRenderEffect(instance: any, vnode: any, container: any) {
  // 把instance.setupState 改成 instance.proxy
  const subTree = instance.render.call(instance.proxy)
  patch(subTree, container)
  vnode.el = subTree.el
}
```

## 巧妙的 vnode 类型分类

上一篇里我们是通过vnode.type判断是否是string类型，object类型来确当这个vnode到底是元素的vnode还是组件的vnode。 
```typescript
function patch(vnode: any, container: any) {
  if(typeof vnode.type === 'string'){
    processElement(vnode, container)
  }else if(isObject(vnode.type)){
    processComponent(vnode, container)
  }
}
```
这样写的话，代码不够优雅，后期vnode代表更多类型的时候，我们就需要在这个函数重新添加判断逻辑。为此我们需要定义一个标识位`shapeFlag`，每个vnode都有一个shapeFlag标识位，用于标识当前的vnode是什么类型。

那在vue源码里面vnode是怎么被标识的呢？我们可以在`shared/src/shapeFlag.ts`中找到答案。如下


```typescript
export const enum ShapeFlags {
  ELEMENT = 1,                         // 0000000001
  FUNCTIONAL_COMPONENT = 1 << 1,       // 0000000010
  STATEFUL_COMPONENT = 1 << 2,         // 0000000100
  TEXT_CHILDREN = 1 << 3,              // 0000001000
  ARRAY_CHILDREN = 1 << 4,             // 0000010000
  SLOTS_CHILDREN = 1 << 5,             // 0000100000
  TELEPORT = 1 << 6,                   // 0001000000
  SUSPENSE = 1 << 7,                   // 0010000000
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,// 0100000000
  COMPONENT_KEPT_ALIVE = 1 << 9,       // 1000000000
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT
}
```
vue源码并不是用对象去存储标识，映射。
```typescript
// 为什么不直接用对象然后属性值是1，2，3，4，5.。。。主要还是性能问题，vue源码在可读性和性能这条分岔路口上，最终还是选择了性能。
export const ShapeFlags = {
  ElEMENT: 1,
  STATEFUL_COMPONENT: 2,
  TEXT_CHILDREN: 3,
  ARRAY_CHILDREN: 4,
}
```
而是通过二进制位运算的方式标识。例如：

> 1 的二进制 是 `0000000001`

左移1位

> `0000000010`

左移2位

> `0000000100`

按照vue源码的方法，

|vnode类型|标识位|
|:--------|:-----|
|element类型|0000000001|
|组件类型|0000000010|
|子级的文本类型|0000000100|

那如果一个vnode的类型是组件，并且子级的节点是文本类型，应该怎么表示？

我们是不是应该在二进制位的右边数起第三位把`0`改成`1`啊

> 0000000110

怎么得到这个值呢？这里需要用到逻辑或运算的知识（运算符两边为0，结果才为0），例如：

$0 | 0 = 0$

$0 | 1 = 1$

那么组件类型逻辑或运算子级文本类型就是：

$0000000010 | 0000000100 = 0000000110$

如何判断这个vnode是组件类型呢？

简单的比较运算符肯定是不行的，`0000000110` !== `0000000010`，这里我们要用到逻辑与运算符（运算符两边都为1，结果才为1），例如：

$1 \& 1 = 1$

$1 \& 0 = 0$

那么判断vnode是不是组件类型将会这么表示：

$0000000110 \& 0000000010 = 0000000010$ 

结果非0，说明该vnode是组件类型，否则不是组件类型。如下：

$0000000101 \& 0000000010 = 0000000000$ 

`0000000101`是元素类型子级文本类型，我们通过`0000000010`判断它是否一个组件类型，结果为0，说明不是组件类型。

上面我们讲了如何判断vnode的类型和给vnode添加多种标识，那么我们来实际用起来吧。先在创建vnode的时候给vnode添加`shapeFlag`

```typescript
export function createVNode(type: any, props?: any, children?: any) {
  const vnode = {
    type,
    props,
    children,
    shapeFlag: getShapeFlag(type), // getShapeFlag是添加标识
    el: null,
  }
  // 根据children的类型，给vnode添加额外的标识
  normalizeChildren(vnode, children)
  return vnode
}
```
```typescript
// 根据vnode.type标志vnode类型
function getShapeFlag(type: any) {
  return isString(type) 
    ? ShapeFlags.ELEMENT
    : isObject(type)
    ? ShapeFlags.STATEFUL_COMPONENT
    : 0
}
```
```typescript
// 给vnode.shapeFlag追加标识
function normalizeChildren(vnode: any, children: any){
  // | 左右两边为0 则为0   可以用于给二进制指定的位数修改成1  例如：0100 | 0001 = 0101
  // 在这里相当于给vnode追加额外的标识
  if(isString(children)){
    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN
    // 子级是数组
  } else if(isArray(children)){
    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN
  }
  // vnode是组件
  if(vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT){
    // 子级是对象
    if(isObject(children) ){
      vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN
    }
  }
}
```
## render 的事件是如何被注册的？



## render 是如何接收外部传入的 props？

在setup中传入，挂载到instance.props上，还要具有shallowReadonly特性

## 子组件定义自定义事件，父组件触发自定义事件

## render 的插槽（作用域插槽、具名插槽）

## 摆脱 div 束缚的解决方案：Fragment 和 Text

## 最后@肝血阅读，栓 Q

## 完整代码
