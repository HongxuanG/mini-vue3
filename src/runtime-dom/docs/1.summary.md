# Vue3 手写 Element 元素的更新

之前我们实现了 element 元素的挂载，还没有实现当元素内的数据发生改变的时候，要对元素进行更新操作。

为此我准备了一个小 demo，期望用户在点击 button 按钮的时候能让`count`加一：

```typescript
import { ref, h } from '../../lib/guide-toy-vue3.esm.js'
export const App = {
  name: 'app',
  setup() {
    const count = ref(0)
    const click = () => {
      count.value++
    }
    return {
      count,
      click,
    }
  },
  render() {
    return h('div', {}, [
      h('p', {}, `count: ${this.count}`),
      h('button', { onClick: this.click }, '点击更新'),
    ])
  },
}
```

[![XwtJqU.md.png](https://s1.ax1x.com/2022/06/05/XwtJqU.md.png)](https://imgtu.com/i/XwtJqU)

可以看到 this.count 并没有打印出数值而是一个`[Object object]`，为什么会这样呢？我们再进一步打印`this.count`是什么。

[![Xwtosf.md.png](https://s1.ax1x.com/2022/06/05/Xwtosf.md.png)](https://imgtu.com/i/Xwtosf)

他是一个 ref 对象，我们想要的值在`_value`里面，那要怎么去除这个值呢？我们之前是不是实现了`proxyRefs`，我当时说过他是用来在 h 函数里面自动解包 ref 的。

生怕你们忘了我在这里再贴一次这段代码的实现吧。

```typescript
// 通常用在vue3 template里面ref取值，在template里面不需要.value就可以拿到ref的值
export function proxyRefs<T extends object>(obj: T) {
  return isReactive(obj)
    ? obj
    : new Proxy<any>(obj, {
        get(target, key) {
          // unref已经处理了是否ref的情况所以我们不需要自己if处理，如果是，返回.value，如果不是，直接返回值
          return unref(Reflect.get(target, key))
        },
        set(target, key, value) {
          // 因为value为普通值类型的情况特殊，要把value赋值给ref的.value
          if (isRef(target[key]) && !isRef(value)) {
            target[key].value = value
            return true
          } else {
            return Reflect.set(target, key, value)
          }
        },
      })
}
```

我们只需要对 setup 的返回值进行解包就好了。

在 runtime-core 里面的 component.ts 里面添加 proxyRefs 的调用操作

```typescript
function handleSetupResult(instance: any, setupResult: any) {
  // TODO handle function
  if (isFunction(setupResult)) {
    instance.render = setupResult
  } else if (isObject(setupResult)) {
    // 把setup返回的对象挂载到setupState上  proxyRefs对setupResult解包
    instance.setupState = proxyRefs(setupResult) // 新增
  }
}
```

这样 ref 的 value 就能正常显示出来了。

[![XwUu3n.md.png](https://s1.ax1x.com/2022/06/05/XwUu3n.md.png)](https://imgtu.com/i/XwUu3n)

下一步我们来完成元素的更新

页面上的元素都是虚拟 dom 对象

```typescript
{
  type: 'div',
  props: {},
  children:{},
  el: {},
  shapeFlag: 2
  ...
}
```

元素更新的时候需要生成新的 vnode 对象，然后通过旧的 vnode 和新的 vnode 进行对比，从而找出要更新的地方。如果是文本更新，那我们可以用 dom.textContext 属性更新。 [![XgflVI.md.png](https://s1.ax1x.com/2022/06/12/XgflVI.md.png)](https://imgtu.com/i/XgflVI)

前提是我们需要获取旧的 vnode 和新的 vnode。新的 vnode 怎么获取？重新执行一次`render`函数就可以了啊，那什么时候应该重新执行一次 render 函数呢？上面的 count 值是一个 ref 响应式对象，只要 count 发生改变，视图中的 text 就应该发生更新啊，render 函数就应该重新执行一次生成一个 vnode 对象。

之前的章节我们实现了`effect`，它的主要作用是响应式对象的值发生改变的时候，会执行一次对该响应式对象相关联的`effect`（触发依赖）。

我们只需要在 render 函数被执行的函数里面，用 effect 包裹起来。等到 count 发生改变的时候，就会重新执行一次 render 函数了。

```typescript
// In renderer.ts
function setupRenderEffect(instance: any, vnode: any, container: any) {
  effect(() => {
    const subTree = instance.render.call(instance.proxy)
    console.log('subTree===>', subTree)
    patch(subTree, container, instance)
    vnode.el = subTree.el
    instance.isMounted = true
  })
}
```

### 依赖收集

```typescript
render() {
  // 触发了ref的get操作（依赖收集）
    return h('div', {}, [
      h('p', {}, `count: ${this.count}`),
      h('button', { onClick: this.click }, '点击更新'),
    ])
  },
```

### 触发依赖

```typescript
setup() {
    const count = ref(0)
    const click = () => {
      // 触发了ref的set操作（执行effect回调函数）
      count.value++
    }
    return {
      count,
      click,
    }
  },
```

[![XgH4PA.md.png](https://s1.ax1x.com/2022/06/12/XgH4PA.md.png)](https://imgtu.com/i/XgH4PA)

根据现在的逻辑，可以看到多次点击 button 之后，虽然 count 更新了，但是重复的元素也被 mount 进 dom 树上面。原因是执行 render 的函数的时候它并不知道组件是否已经被挂载。

所以需要在组件实例上新增一个属性`isMounted`，该属性值是 boolean 类型，表示组件是否已经被挂载。

```typescript
export function createComponentInstance(vnode: any, parentComponent: any) {
  console.log('createComponentInstance', parentComponent)
  const type = vnode.type
  const instance = {
    vnode,
    type,
    render: null,
    setupState: {},
    props: {},
    emit: () => {},
    slots: {},
    isMounted: false, // 新增
    provides: parentComponent
      ? parentComponent.provides
      : ({} as Record<string, any>),
    parent: parentComponent,
  }
  instance.emit = emit.bind(null, instance) as any
  return instance
}
```

更改 setupRenderEffect 内部逻辑

```typescript
function setupRenderEffect(instance: any, vnode: any, container: any) {
  effect(() => {
    if (!instance.isMounted) {
      // 这里处理第一次被挂载的逻辑
      const subTree = instance.render.call(instance.proxy)
      instance.subTree = subTree
      patch(null, subTree, container, instance)
      vnode.el = subTree.el
      instance.isMounted = true
    } else {
      // 这里处理更新的逻辑
      console.log('update')
    }
  })
}
```

> 注意：第一次被挂载的逻辑完成之后，还需要把 isMounted 设置为 true，这样下次更新的时候，就不会执行第一次的逻辑了。

我们把注意力聚焦到更新的逻辑。

我们需要两个 vnode，新的和旧的，所以我们同样要执行一遍 render 函数，为了能在更新的时候拿到老的 vnode，我们还需要在上一次 render 函数执行的时候得到的 vnode 赋值给一个新的属性`subTree`，这个属性同样是在组件实例 instance 上。

这就很好解释了为什么我在第一次挂载的逻辑中加入了`instance.subTree = subTree`这个表达式。

```typescript
export function createComponentInstance(vnode: any, parentComponent: any) {
  console.log('createComponentInstance', parentComponent)
  const type = vnode.type
  const instance = {
    vnode,
    type,
    render: null,
    setupState: {},
    props: {},
    emit: () => {},
    slots: {},
    isMounted: false,
    subTree: {}, // 新增
    provides: parentComponent
      ? parentComponent.provides
      : ({} as Record<string, any>),
    parent: parentComponent, // 父组件的组件实例
  }
  instance.emit = emit.bind(null, instance) as any
  return instance
}

function setupRenderEffect(instance: any, vnode: any, container: any) {
  effect(() => {
    if (!instance.isMounted) {
      // 这里处理第一次被挂载的逻辑
      const subTree = instance.render.call(instance.proxy)
      instance.subTree = subTree
      patch(null, subTree, container, instance)
      vnode.el = subTree.el
      instance.isMounted = true
    } else {
      // 这里处理更新的逻辑
      // 新的vnode
      const subTree = instance.render.call(instance.proxy)
      // 老的vnode
      const prevSubTree = instance.subTree
      // 存储这一次的vnode，下一次更新逻辑作为老的vnode
      instance.subTree = subTree
      patch(prevSubTree, subTree, container, instance)
    }
  })
}
```

## element 的 props 更新

我们讲一下元素的属性的更新。

有三种情况需要我们处理：

1. 新的 props 和旧的 props 不同（新增，修改）
2. 新的 props 被赋值为 null 或者 undefined（删除）
3. 旧的 props 有些属性在新的 props 中没有（删除）

[![X2VJHg.png](https://s1.ax1x.com/2022/06/12/X2VJHg.png)](https://imgtu.com/i/X2VJHg)

目前我们只处理元素的情况，所以我们在`patch`中只修改`processElement`内部的逻辑。

给 patch 传入`n1`和`n2`，其中 n1 代表旧的 vnode，n2 代表新的 vnode。

```typescript
function patch(n1: any, n2: any, container: any, parentComponent: any) {
  // 检查是什么类型的vnode
  const { type } = n2
  switch (type) {
    case Fragment:
      processFragment(n2, container, parentComponent)
      break
    case Text:
      processText(n2, container)
      break
    default: {
      if (n2.shapeFlag & ShapeFlags.ELEMENT) {
        processElement(n1, n2, container, parentComponent)
      } else if (n2.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
        // 是一个组件？处理vnode是组件的情况
        processComponent(n2, container, parentComponent)
      }
      break
    }
  }
}
```

当 n2 的 shapeFlag 表示元素的时候，我们同样把 n1 和 n2 传入 processElement 函数。

```typescript
// 处理元素的情况
function processElement(
  n1: any,
  n2: any,
  container: any,
  parentComponent: any
) {
  if (!n1) {
    mountElement(n2, container, parentComponent)
  } else {
    patchElement(n1, n2, container)
  }
}
```

其中需要处理 n1 为 null 的情况，即第一次挂载到 dom 上的情况，否则对 n1 和 n2 做对比 patch。我把对比的操作抽离成了一个函数 `patchElement`。

patchElement 的具体实现如下：

```typescript
function patchElement(n1: any, n2: any, container: any) {
  // 这里的EMPTY_OBJ是一个空对象，在shareFlags.ts中定义：const EMPTY_OBJ = {}
  const oldProps = n1.props || EMPTY_OBJ
  const newProps = n2.props || EMPTY_OBJ
  const el = (n2.el = n1.el)
  patchProps(el, oldProps, newProps)
}
```

在`patchProps()`内部遍历 n2（新的 vnode）的 props，看看 n1 的 props 和 n2 的 props 是否相同。

```typescript
// newProps就是n2.props
// oldProps就是n1.props
for (let key in newProps) {
  const newProp = newProps[key]
  const oldProp = oldProps[key]
  if (newProp !== oldProp) {
    patchProp(el, key, oldProp, newProp)
  }
}
```

`patchProp()`在之前的篇章已经出现过了，它是通过 DOM API 将 h 函数的 prop（h 函数的第二个参数）赋值给真实的 dom 元素。这里我可以重新贴一下具体的代码实现。

```typescript
export function patchProp(el: any, key: string, oldValue: any, newValue: any) {
  // 这里处理属性值有多个的情况，比如class="flex flex-column flex-grow-1"
  if (Array.isArray(newValue)) {
    el.setAttribute(key, newValue.join(' '))
  } else if (isOn(key) && isFunction(newValue)) {
    el.addEventListener(key.slice(2).toLowerCase(), newValue)
  } else {
    el.setAttribute(key, newValue)
  }
}
```

其实到这里后已经实现了三种情况的第一种了（新增和修改）

当 n2 的 props 有属性值是 null 或者 undefined 的时候，我们也应该移除这个属性。此时我们可以修改`patchProp`

```typescript
export function patchProp(el: any, key: string, oldValue: any, newValue: any) {
  if (Array.isArray(newValue)) {
    el.setAttribute(key, newValue.join(' '))
  } else if (isOn(key) && isFunction(newValue)) {
    // 添加事件
    el.addEventListener(key.slice(2).toLowerCase(), newValue)
  } else {
    // props属性的属性值是undefined或者null，删除该属性
    if (newValue === null || newValue === undefined) {
      el.removeAttribute(key)
    } else {
      el.setAttribute(key, newValue)
    }
  }
}
```

这样就是实现了第二种情况了

接着因为需要检查 n1 的 props 是不是在 n2 的 props 中被删除了，所以我们需要遍历 n1 的 props，看看是不是在 n2 的 props 中不复存在。

```typescript
for (let key in oldProps) {
  // 新的props没有该属性
  if (!(key in newProps)) {
    patchProp(el, key, oldProps[key], null)
  }
}
```

要想删除属性，只需要给 patchProp 传入 null 即可，在内部会调用`el.removeAttribute`。

好了，三种情况都已经解决了。

## element 的 children 更新

element 的 children 更新涉及到以下四种情况：

1. 旧的子节点是 array 类型 ==> 新的子节点是 string 类型
2. 旧的子节点是 string 类型 ==> 新的子节点是 string 类型
3. 旧的子节点是 string 类型 ==> 新的子节点是 array 类型
4. 旧的子节点是 array 类型 ==> 新的子节点是 array 类型

当然其他情况比如旧的子节点是空的，新的子节点可能是空的。

### 第一种情况：子节点从数组变为字符串

[![XOMoz4.png](https://s1.ax1x.com/2022/06/18/XOMoz4.png)](https://imgtu.com/i/XOMoz4)

> 其中`shapeFlag`是区分 vnode 的一个标识

以下为用于解决这种元素 children 更新的测试 demo

```typescript
export const App = {
  name: 'app',
  setup() {},
  render() {
    // this.count进行依赖收集，
    return h('div', {}, [
      h('p', {}, '主页'),
      // 旧的是数组 新的是文本
      h(arrayToText),
    ])
  },
}
export default {
  name: 'arrayToText',
  setup() {
    const isChange = ref(false)
    // 把ref对象挂载在window是为了方便在外部改变ref的值
    window.isChange = isChange
    return {
      isChange,
    }
  },
  render() {
    return this.isChange
      ? h('div', {}, 'new text')
      : h('div', {}, [h('div', {}, 'A'), h('div', {}, 'B')])
  },
}
```

预期需求：

当我在 console 中输入`isChange.value = true`，然后在浏览器中查看结果，会发现子节点从显示'A'和'B'更新为'new text'。这样就能达到数据驱动视图的效果。

由于之前已经实现了`setupRenderEffect()`内部的逻辑，可以让 ref 更新的时候，重新执行 patch 函数。我们只需要在调用`patchProps()`的地方上新增实现`patchChildren`函数

patchChildren 内部逻辑是怎样的呢？

当子节点的 shapeFlag 是数组的时候，遍历这个数组，并依次 removeChild 做卸载，之后通过 textContent 把文本更新上去。

```typescript
function patchChildren(n1: any, n2: any, container: any, parentComponent: any) {
  const prevShapeFlag = n1.shapeFlag
  const newShapeFlag = n2.shapeFlag
  const c1 = n1.children
  const c2 = n2.children
  if (newShapeFlag & ShapeFlags.TEXT_CHILDREN) {
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // 卸载旧的子节点
      unmountChildren(container)
      // 设置元素文本
      setElementText(container, c2)
    }
  }
}
function unmountChildren(child: any) {
  for (let i = 0; i < child.length; i++) {
    remove(child[i])
  }
}
export function remove(child: HTMLElement) {
  // 这里为什么不直接用child.remove()呢？可以用，不过这样写兼容性更好而已
  const parent = child.parentNode
  if (parent) {
    parent.removeChild(child)
  }
}
// 设置元素文本
export function setElementText(el: HTMLElement, text: string) {
  el.textContent = text
}
```

### 第二种情况：子节点从字符串变为数组

[![XOYrKU.png](https://s1.ax1x.com/2022/06/18/XOYrKU.png)](https://imgtu.com/i/XOYrKU)

以下为用于解决这种元素 children 更新的测试 demo

```typescript
export const App = {
  name: 'app',
  setup() {},
  render() {
    return h('div', {}, [
      h('p', {}, '主页'),
      // 旧的是文本 新的是数组
      h(textToArray),
    ])
  },
}
export default {
  name: 'textToArray',
  setup() {
    const isChange = ref(false)
    window.isChange = isChange
    return {
      isChange,
    }
  },
  render() {
    return this.isChange
      ? h('div', {}, [h('p', {}, 'p标签'), h('span', {}, 'span标签')])
      : h('div', {}, 'old text')
  },
}
```

预期需求：

跟情况一正好相反，当我在 console 中输入`isChange.value = true`，然后在浏览器中查看结果，会发现子节点从显示'old text'更新为'A'和'B'。这样就能达到数据驱动视图的效果。

实现思路：

先把子节点重新通过 textContext 设置为空字符串，再通过已经实现的 mountChildren 函数，把新的子节点挂载上去。不过在此之前还是要通过 shapeFlag 判断一下 vnode 的类型。

```typescript
// n1是旧节点  n2是新节点
function patchChildren(n1: any, n2: any, container: any, parentComponent: any) {
  const prevShapeFlag = n1.shapeFlag
  const newShapeFlag = n2.shapeFlag
  const c1 = n1.children
  const c2 = n2.children
  // 判断新节点的shapeFlag是否是文本
  if (newShapeFlag & ShapeFlags.TEXT_CHILDREN) {
    // 判断旧节点的shapeFlag是否是数组
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // array to text
      unmountChildren(container)
      setElementText(container, c2)
    }
  } else {
    // text to array
    if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
      setElementText(container, '')
      // 挂载新的子节点
      mountChildren(c2, container, parentComponent)
    }
  }
}
```

### 第三种情况：子节点从旧的文本更新为新的文本

这种情况相对简单，只需要判断 n1.children 和 n2.children 是不是相等的，如果不是则利用 textContext 更新文本即可。相等就没必要往下了，节省性能。

[![XONPOO.png](https://s1.ax1x.com/2022/06/18/XONPOO.png)](https://imgtu.com/i/XONPOO) 同时针对上面的 patchChildren 我们可以优化以下逻辑：

```typescript
// n1是旧节点 n2是新节点
function patchChildren(n1: any, n2: any, container: any, parentComponent: any) {
  const prevShapeFlag = n1.shapeFlag
  const newShapeFlag = n2.shapeFlag
  const c1 = n1.children
  const c2 = n2.children
  if (newShapeFlag & ShapeFlags.TEXT_CHILDREN) {
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      unmountChildren(container)
    }
    // 判断是否相等，单独把`setElementText`拿出来，兼容了第一种和第三种情况
    if (c1 !== c2) {
      setElementText(container, c2)
    }
  } else {
    // text to array
    if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
      setElementText(container, '')
      mountChildren(c2, container, parentComponent)
    }
  }
}
```

第四种情况旧节点是数组，新节点是数组，patch 的时候相对复杂涉及到 vue 的 diff 算法。

## 双端对比 diff 算法

### 左侧对比

先来一张图给大家看看，咱们先别看右侧的流程图（那是关于往右侧新增节点的流程）

`图1` [![jFbS3R.md.png](https://s1.ax1x.com/2022/06/25/jFbS3R.md.png)](https://imgtu.com/i/jFbS3R)

解析：

c1：旧的子节点的数组，比如：有 A、B 两个元素

c2：新的子节点的数组，比如：有 A、B、C、D 四个元素

i：头部指针，初始为 0，将会向右移动

e1：旧节点数组的指针，指针指向数组末尾，初始化值为`c1.length - 1`

e2：新节点数组的指针，指针指向数组末尾，初始化值为`c2.length - 1`

要想知道有哪些节点是需要被新增的，那不得遍历两个数组进行比较嘛，相同就证明不需要新增，不相同就证明旧节点数组没有，新节点数组有的元素，这要新增元素了。这就引出一个索引值`i`，通过索引值可以得出要新增哪些节点以及新增节点的范围。比如上图中，`e1 < i <= e2`这个范围就是需要新增节点的范围。i 在什么条件下会移动呢？当然是`c1[i]`和`c2[i]`有值的时候啊，所以当`i<=e1 && i<=e2`，要判断`c1[i]`和`c2[i]`是否是相同的 vnode，如果相同就`i++`，下一轮循环的时候根据这个已自增的 i 取得 vnode。有进行下一轮的`比较`。

而这个比较方法`isSameVNodeType()`的实现就是根据 vnode 的 type 属性和 key 属性进行比较。

```typescript
// n1是旧的vnode n2是新的vnode 返回boolean
function isSameVNodeType(n1: any, n2: any) {
  return n1.type === n2.type && n1.key === n2.key
}
```

所以为什么 vue3 里面渲染列表的时候 v-for 后面要顺便定义 key，就是为了能精准确定两个 vnode 节点是不是相同的 vnode，从而提升渲染时的性能。

如果发现两个 vnode 节点是相同的节点，那么调用 patch 方法，否则直接跳出循环，拿到这个`i`值，这个 i 值就是要新增节点的开始索引值。

```typescript
while (i <= e1 && i <= e2) {
  const n1 = c1[i] // 旧的vnode节点
  const n2 = c2[i] // 新的vnode节点
  if (isSameVNodeType(n1, n2)) {
    patch(n1, n2, container, parentComponent, anchor)
  } else {
    break
  }
  i++
}
```

### 右侧对比

`图2` [![jkF0LF.md.png](https://s1.ax1x.com/2022/06/25/jkF0LF.md.png)](https://imgtu.com/i/jkF0LF)

和左侧对比的方向相反，注意的是：右侧对比不再以 i 为索引获取 vnode 节点，而是用 e1 和 e2 作为索引获取 vnode，并且不再对 i 自增，反而利用 e1 和 e2 自减来获取不同的 vnode 节点。但是判断条件还是一样的`i <= e1 && i <= e2`，i 始终为 0。

```typescript
while (i <= e1 && i <= e2) {
  const n1 = c1[e1]
  const n2 = c2[e2]
  if (isSameVNodeType(n1, n2)) {
    patch(n1, n2, container, parentComponent, anchor)
  } else {
    break
  }
  e1--
  e2--
}
```

左侧对比结合右侧对比就能处理以下情况了。 [![jkEMM6.md.png](https://s1.ax1x.com/2022/06/25/jkEMM6.md.png)](https://imgtu.com/i/jkEMM6)

### 新增节点

新增节点我们使用[`Node.insertBefore()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore)，第一个入参用于插入的节点，第二个入参用于指定插在哪个节点之前，如果入参为 null，将会插入的节点插入到末尾。

我们可以利用第二个入参为 null 来实现右侧添加节点。至于往左侧添加节点我们可以在第二个参数填上对应的引用节点就好。

`图1`中循环下来 i、e1、e2 的值分别是：

```
i: 2
e1: 1
e2: 3
```

`图2`中循环下来 i、e1、e2 的值分别是：

```
i: 0
e1: -1
e2: 1
```

可以看出：i 始终大于 e1，始终小于等于 e2

```typescript
if (i > e1) {
  if (i <= e2) {
    const nextPos = e2 + 1
    // c2[nextPos].el 将会拿到 Node实例 ，c2[nextPos]是vnode对象
    const anchor = nextPos < c2.length ? c2[nextPos].el : null

    while (i <= e2) {
      // 新增
      patch(null, c2[i], container, parentComponent, anchor)
      i++
    }
  }
}

// 核心的新增节点函数
export function insert(child: any, container: any, anchor: any = null) {
  container.insertBefore(child, anchor)
}
```

anchor 是作为一个锚点的存在，当右侧添加节点的时候，它将会是 null，会传入 insertBefore 的第二个参数。当需要左边添加节点的时候，他将作为被插入节点的下一个节点。这里可能很难理解，我打个比方：

`图2`中需要我们插入 C 和 D 到 A 之前，那么这个 anchor 锚点就是 A。前面两个 while 循环（分别是左侧对比和右侧对比）走完之后，i 还是 0，e1 是-1，e2 是 1。最后`nextPos = 2`，`nextPos < c2.length`这个判断自然就走 true 了，而`c2[nextPos].el`就是 A。

在下一段代码 patch 的时候，内部调用 insertBefore 就能把 D、C 插入到 A 之前，仔细你会发现其实是先插入 D 再插入 C 的 🤣。

😟why？为什么是先插入 D 再插入 C 呢？

因为 i 为 0，`c2[i]`取得是 c2 的第一个元素（D）进行 patch，patch 完之后 i 自增加一，这时候才开始取第二个元素（C）进行 patch。

```typescript
while (i <= e2) {
  // 新增
  patch(null, c2[i], container, parentComponent, anchor)
  i++
}
```

### 删除节点

[![jk1wVI.md.png](https://s1.ax1x.com/2022/06/25/jk1wVI.md.png)](https://imgtu.com/i/jk1wVI) 左侧删除节点时：i、e1、e2 的值分别是：

```
i: 2
e1: 3
e2: 1
```

右侧删除节点时：i、e1、e2 的值分别是：

```
i: 0
e1: 1
e2: -1
```

可以知道规律：c1 的数组长度大于 c2 的数组长度的时候，需要删除节点。删除的范围将会是：`i > e2`的时候

```typescript
if (i > e2) {
  while (i <= e1) {
    remove(c1[i].el)
    i++
  }
}

// 删除节点的核心函数
// 这里可以换成 child.remove()
export function remove(child: HTMLElement) {
  const parent = child.parentNode
  if (parent) {
    parent.removeChild(child)
  }
}
```

右侧删除节点，删除的顺序是：C、D

左侧删除节点，删除的顺序是：A、B

### 进入真正的diff场景
diff有几个场景：
1. 删除场景：旧节点的子节点中间部分中某一个节点在新节点的子节点中不存在。旧节点需要删除该子节点。
2. 新增场景：新节点的子节点中间部分中某一个节点在旧节点的子节点中不存在。旧节点需要新增该子节点。
3. 更新场景：旧节点的子节点某一个节点在新节点的子节点中状态发生改变了。旧节点需要更新该子节点。
4. 移动场景：旧节点的子节点某一个节点在新节点的子节点中位置发生改变了。旧节点需要移动该子节点到目标位置。

先考虑删除和更新的逻辑（交换位置和新增节点逻辑先不考虑）

这里给一个例子：

[![jEZVvn.md.png](https://s1.ax1x.com/2022/06/26/jEZVvn.md.png)](https://imgtu.com/i/jEZVvn)

我们把之前的左端对比和右端对比结合起来，计算出 i、e1、e2 的值就能知道中间部分的范围在哪了。

上图所示：中间部分的范围：i ~ e1、i ~ e2

目光聚焦到 c1 和 c2 的中间部分，都有 C，但是 C 的 property 并不相同，主要还是 id 不一样，需要 patch。再看 D，D 在 c2 数组里面是没有的，所以 D 需要被删除。

那怎么知道 c1 的元素在 c2 有没有呢？那就需要双重遍历了，先遍历 c1 的中间部分，拿到 c1 的索引值再遍历 c2 的中间部分，拿着这个 c1 的元素依次跟 c2 的元素进行比较，第一轮比较完之后接着拿 c1 的下一个元素跟 c2 的元素进行比较。不过这样做的话时间复杂度是 O(n^2)。要想快速找到 c1 的元素对应再 c2 上有没有，我们可以用映射查找的方式（Map）。

先把 c2 的中间部分的每一个元素的索引值都存入一个 Map 中。当遍历 c1 的时候，首先去 Map 查找看看有没有对应的元素。如果有值，直接走 patch，如果没有值，才用上面所说的双重遍历的方式查找，还是没有查找到在 c2 对应的元素呢？说明该元素是需要被删除的。当然如果查找到了还是走 patch。这样时间复杂度就从 O(n^2)变成 O(1)了。这也是为什么列表渲染的时候我们必须给元素添加一个唯一值 key 提升渲染性能

```typescript
// 处理中间部分
// a b (c d) e f
// a b (e c) e f
let s1 = i
let s2 = i
// 为了能使用映射查找方式需要的map容器，提高patch的效率
const keyToNewIndexMap = new Map()
// 遍历c2中间部分
for (let i = s2; i <= e2; i++) {
  const nextChild = c2[i]
  keyToNewIndexMap.set(nextChild.key, i)
}
// 遍历c1中间部分，找出c1在c2对应的元素，如果找不到，就删除，找到了就更新走patch
// 遍历旧节点
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i]
  let nextIndex

  if (prevChild.key != null) {
    nextIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    for (let j = s2; j <= e2; j++) {
      if (isSameVNodeType(prevChild, c2[j])) {
        nextIndex = j
        break
      }
    }
  }
  if (nextIndex === undefined) {
    hostRemove(prevChild.el)
  } else {
    patch(prevChild, c2[nextIndex], container, parentComponent, null)
  }
}
```

Map 实际上用 vnode.key 作为键去存储 c2 元素的索引值，这个 vnode.key 就是上面代码中的`nextChild.key`和`prevChild.key`，这也是为什么列表渲染的时候我们必须给元素添加一个唯一值 key 提升渲染性能。

### 删除逻辑的优化点：

上面的代码就是删除节点和更新节点的逻辑了，其中也有一个可以优化的点，那就是当知道 c2 中的元素都已经被比较过了以后，c1 中剩余的元素就没必要处理了，直接删除，提高了性能。 [![jEVbND.md.png](https://s1.ax1x.com/2022/06/26/jEVbND.md.png)](https://imgtu.com/i/jEVbND)

如图，红色部分为新增代码。

我们需要定义两个变量：

```
toBePatched：表示需要patch的元素的数量
patched：表示已经patch的元素的数量
```


已经执行了patch处理的时候，我们可以把patched自增加一，当`patched >= toBePatched`时，也就是说该 patch 的都已经 patch 完了，那剩下 c1 的元素干嘛管他呢，都认定为 c2 中没有的元素，代表要删除的元素，直接 remove 掉就好了。之后的流程不必往下走了直接进入下一轮循环。



```typescript
let s1 = i
let s2 = i
// 新增
let toBePatched = e2 - s2 + 1
let patched = 0
const keyToNewIndexMap = new Map()
// 遍历c2中间部分
for (let i = s2; i <= e2; i++) {
  const nextChild = c2[i]
  keyToNewIndexMap.set(nextChild.key, i)
}
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i]
  let newIndex
  // 如果该patch的都已经patch完了，之后的元素直接remove掉
  if (patched >= toBePatched) {
    hostRemove(prevChild.el)
    continue
  }
  if (prevChild.key != null) {
    newIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    for (let j = s2; j <= e2; j++) {
      if (isSameVNodeType(prevChild, c2[j])) {
        newIndex = j
        break
      }
    }
  }
  if (newIndex === undefined) {
    hostRemove(prevChild.el)
  } else {
    patch(prevChild, c2[newIndex], container, parentComponent, null)
    // 被patched的数量 +1
    patched++
  }
}
```
### 移动节点逻辑

[![jMy4oD.md.png](https://s1.ax1x.com/2022/07/01/jMy4oD.md.png)](https://imgtu.com/i/jMy4oD)

上图是diff算法中需要处理的节点的位置变更场景，通常我们说的diff的节点移动逻辑。

图中E被移动到了C、D的前面，而C、D也跟着发生位置的变换，如果我们思考移动逻辑该怎么实现的话，我们会很自然的想到，遍历c2，让c2的每一个元素和c1的元素进行比较，看看位置是否发生变化，发生变化就移动到新位置。但是！这种移动逻辑真的太消耗性能了，找这样的逻辑，就需要移动三遍，执行三次`insertBefore`。

我们不妨换一种逻辑，仔细观察，C、D它们之间的关系并没有发生改变，C、D排列顺序不变，只是E被移动到了C、D的前面，那我们只需要对E执行一次`insertBefore`就好了啊。

> 那怎么确定我们要移动的是E呢？而不是C或者D呢？换言之，哪些是需要被移动的，哪些是不需要移动的？

首先我们可以给c1的中间部分的节点添加一个索引（关于怎么确定中间部分就是通过i，e1，e2这些指针来确定i的变化范围）

```
索引 2 3 4
    C D E


    
```


```typescript
```
### 新增节点逻辑


### 使用moved标识符优化性能 
