## element元素的更新

为此我准备了一个小demo，期望用户在点击button按钮的时候能让`count`加一：
```typescript
import { ref, h } from '../../lib/guide-toy-vue3.esm.js'
export const App = {
  name: 'app',
  setup() {
    const count = ref(0)
    const click = ()=>{
      count.value++
    }
    return {
      count,
      click
    }
  },
  render() {
    return h('div', {}, [
      h('p', {}, `count: ${this.count}`),
      h('button', {onClick: this.click}, '点击更新')
    ])
  },
}

```



[![XwtJqU.md.png](https://s1.ax1x.com/2022/06/05/XwtJqU.md.png)](https://imgtu.com/i/XwtJqU)

可以看到this.count并没有打印出数值而是一个`[Object object]`，为什么会这样呢？我们再进一步打印`this.count`是什么。

[![Xwtosf.md.png](https://s1.ax1x.com/2022/06/05/Xwtosf.md.png)](https://imgtu.com/i/Xwtosf)

他是一个ref对象，我们想要的值在`_value`里面，那要怎么去除这个值呢？我们之前是不是实现了`proxyRefs`，我当时说过他是用来在h函数里面自动解包ref的。

生怕你们忘了我在这里再贴一次这段代码的实现吧。
```typescript
// 通常用在vue3 template里面ref取值，在template里面不需要.value就可以拿到ref的值
export function proxyRefs<T extends object>(obj: T) {
  return isReactive(obj)
    ? obj
    : new Proxy<any>(obj, {
        get(target, key) {
          // unref已经处理了是否ref的情况所以我们不需要自己if处理，如果是，返回.value，如果不是，直接返回值
          return unref(Reflect.get(target, key))
        },
        set(target, key, value) {
          // 因为value为普通值类型的情况特殊，要把value赋值给ref的.value
          if (isRef(target[key]) && !isRef(value)) {
            target[key].value = value
            return true
          } else {
            return Reflect.set(target, key, value)
          }
        },
      })
}
```
我们只需要对setup的返回值进行解包就好了。

在runtime-core里面的component.ts里面添加proxyRefs的调用操作
```typescript
function handleSetupResult(instance: any, setupResult: any) {
  // TODO handle function
  if (isFunction(setupResult)) {
    instance.render = setupResult
  } else if (isObject(setupResult)) {
    // 把setup返回的对象挂载到setupState上  proxyRefs对setupResult解包
    instance.setupState = proxyRefs(setupResult) // 新增
  }
}
```
[![XwUu3n.md.png](https://s1.ax1x.com/2022/06/05/XwUu3n.md.png)](https://imgtu.com/i/XwUu3n)

用户点击按钮的时候ref发生改变，因为ref是个响应式对象，他会发生触发依赖的操作，我们可以在触发依赖的时候让他生成一个新的vnode，然后通过旧的vnode和新的vnode进行对比，从而找出要更新的地方。


